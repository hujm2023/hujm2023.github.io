<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>优秀数据结构--默克尔树 | hujm2023&#39;s blog</title>
<meta name="keywords" content="默克尔树, MerkleTree">
<meta name="description" content="一、简介
默克尔树是一种典型的二叉树结构，由一个根节点、一组中间节点 和 一组叶节点 组成。默克尔树最早由 Merkle Ralf 在 1980 年提出，曾广泛用于 文件系统 和 P2P 系统中，比如 Git、区块链、IPFS 等大名鼎鼎的项目或技术。
他又被称为 哈希树，即存储哈希值的树。树的叶子结点是 数据块(文件或者对象)的哈希值，而非叶子结点保存的是其子节点连接起来后的哈希值。简单来说，它有以下特点：">
<meta name="author" content="JemmyHu(hujm20151021@gmail.com)">
<link rel="canonical" href="http://localhost:1313/posts/%E4%BC%98%E7%A7%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css" integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn&#43;yY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/%E4%BC%98%E7%A7%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="hujm2023&#39;s blog (Alt + H)">hujm2023&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      优秀数据结构--默克尔树
    </h1>
    <div class="post-meta"><span title='2020-10-22 15:21:59 +0000 UTC'>October 22, 2020</span>&nbsp;·&nbsp;<span>JemmyHu(hujm20151021@gmail.com)</span>

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="https://pic.downk.cc/item/5f9104531cd1bbb86ba7e0ac.png" alt="">
        
</figure>
  <div class="post-content"><h2 id="一简介">一、简介<a hidden class="anchor" aria-hidden="true" href="#一简介">#</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Merkle_tree">默克尔树</a>是一种典型的二叉树结构，由<strong>一个根节点</strong>、<strong>一组中间节点</strong> 和 <strong>一组叶节点</strong> 组成。默克尔树最早由 <code>Merkle Ralf </code>在 1980 年提出，曾广泛用于 <strong>文件系统</strong> 和 <strong>P2P</strong> 系统中，比如 <code>Git</code>、区块链、<code>IPFS</code> 等大名鼎鼎的项目或技术。</p>
<p>他又被称为 <strong>哈希树</strong>，即存储哈希值的树。树的叶子结点是 <strong>数据块</strong>(文件或者对象)的哈希值，而非叶子结点保存的是其子节点连接起来后的哈希值。简单来说，它有以下特点：</p>
<ul>
<li>最下面的叶节点包含存储数据或其哈希值。</li>
<li>非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。</li>
<li>如果是奇数个叶子结点，那么其父节点保存的哈希值就是它本身或者复制一份自己凑成对再进行哈希的结果(具体实现取决于实际情况)</li>
</ul>
<p>当然，默克尔树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点的内容的哈希值。</p>
<h2 id="二原理与用途">二、原理与用途<a hidden class="anchor" aria-hidden="true" href="#二原理与用途">#</a></h2>
<p>最开始，我们有一组已经准备好的数据块(比如文件)，他们根据某个标准有序(比如根据文件名字典排序)，而每一个文件都有唯一的哈希值与之对应。这是最底层的情况，当我们向上走的时候，每两个当前层的节点(左右孩子结点)的哈希值可以重新组合，形成一个新的节点(父节点)，这个新的结点中不存储数据，其哈希值为左右孩子结点组合后再次使用预设的哈希函数求哈希值。如此以往，直到生成树根，这个树根我们称为 <code>Merkel Root</code>。有一个特殊情况需要注意，有可能某一层的节点数是奇数，这样就会剩下最后一个结点，再没有结点与其组队生成父节点，这种情况下有两种解决方案：一种是复制一份自己；另一种是不复制，让其父节点只有它一个子节点，而且是左孩子结点。</p>
<p>目前，默克尔树的典型应用场景包括如下几种。</p>
<h3 id="快速比较大量数据">快速比较大量数据<a hidden class="anchor" aria-hidden="true" href="#快速比较大量数据">#</a></h3>
<p>对每组数据排序后构建默克尔树结构。当两个默克尔树根相同时，则意味着所代表的两组数据必然相同。否则，必然不同。</p>
<p>由于 Hash 计算的过程可以十分快速，预处理可以在短时间内完成。利用默克尔树结构能带来巨大的比较性能优势。</p>
<h3 id="快速定位修改">快速定位修改<a hidden class="anchor" aria-hidden="true" href="#快速定位修改">#</a></h3>
<p><img alt="默克尔树" loading="lazy" src="https://pic.downk.cc/item/5f9104531cd1bbb86ba7e0ac.png"></p>
<p>假如我们基于文件 <code>D0~D3</code> 构建如上的默克尔树，如果 <code>D2</code> 被修改，那么会影响到结点 <code>N2</code>、<code>N2</code> 和 <code>Root</code>。此时我们可根据发生变化的节点，沿着 <code>Root -&gt; N5 -&gt; N2</code>， 通过 <code>O(logN)</code> 的时间复杂度快速定位到哪个结点发生了变化。</p>
<h3 id="零知识证明">零知识证明<a hidden class="anchor" aria-hidden="true" href="#零知识证明">#</a></h3>
<p>它指的是证明者能够在不向验证者提供任何有用的信息的情况下(没有泄露信息)，使验证者相信某个论断是正确的。有一个很简单的例子：A 要向 B 证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有 2 个方法：</p>
<ol>
<li>
<p>A 把钥匙出示给 B，B 用这把钥匙打开该房间的锁，从而证明 A 拥有该房间的正确的钥匙。</p>
</li>
<li>
<p>B 确定该房间内有某一物体，A 用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给 B，从而证明自己确实拥有该房间的钥匙。</p>
</li>
</ol>
<p>后面的第二种方法属于零知识证明。它的好处在于，在整个证明的过程中，B 始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p>
<p>在默克尔树中，我们仍旧以上图为例，如何向他人证明我拥有 <code>D0</code> 这个数据，而不用暴露更多系统的信息呢？模仿上面的例子，验证者随机提供数据 <code>D1</code>、<code>D2</code> 和 <code>D3</code>，证明者构造如图的默克尔树，并公布 <code>N1</code> 、<code>N5</code> 和 <code>Root</code>。验证者自行计算 <code>Root</code> 值，看是否一致，从而检验 <code>D0 </code> 是否存在，因为如果存在，<code>N0</code> 一定相同，那么 <code>N4(N0-N1)</code> 也一定相同、<code>Root(N4-N5)</code>也一定相同。整个过程中验证着没有得到任何除了 <code>D0</code> 外的敏感信息(其他的 <code>D</code>)。</p>
<h2 id="三golang-实现">三、Golang 实现<a hidden class="anchor" aria-hidden="true" href="#三golang-实现">#</a></h2>
<p>首先，我们定义需要的结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Node 表示默克尔树中的 叶结点、非叶结点 或者 Root</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Tree</span>   <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span> <span style="color:#75715e">// 所在的 Merkle Tree</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Parent</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>       <span style="color:#75715e">// 父节点</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Left</span>   <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>       <span style="color:#75715e">// 左孩子</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Right</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>       <span style="color:#75715e">// 右孩子</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">leaf</span>   <span style="color:#66d9ef">bool</span>        <span style="color:#75715e">// 是否叶子结点</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Hash</span>   []<span style="color:#66d9ef">byte</span>      <span style="color:#75715e">// 如果是叶子结点，则为叶子结点数据的哈希值；如果是非叶子结点，则为左右孩子哈希值组合后的哈希值</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">C</span>      <span style="color:#a6e22e">Content</span>     <span style="color:#75715e">// 叶子结点存储的数据块</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Content 代表一个数据块</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Content</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">CalculateHash</span>() ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Equals</span>(<span style="color:#a6e22e">other</span> <span style="color:#a6e22e">Content</span>) (<span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// MerkleTree 默克尔树</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MerkleTree</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Root</span>         <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>            <span style="color:#75715e">// Merkle Root 树根</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">merkleRoot</span>   []<span style="color:#66d9ef">byte</span>           <span style="color:#75715e">// 树根的哈希值</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Leafs</span>        []<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>          <span style="color:#75715e">// 所有的叶子结点</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hashStrategy</span> <span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">hash</span>.<span style="color:#a6e22e">Hash</span> <span style="color:#75715e">// 计算哈希的方法</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>需要注意的是，<code>hashStrategy</code> 是一个函数，其返回 <code>type hash.Hash interface</code>，目前最常见的实现是 <code>sha256.New</code> 等，这里为了说明清楚原理，我们自己实现一个，计算 <code>hash</code> 时，只是简单将其转化为 <code>[]byte</code> 即可：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">myHash</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">hash</span>      []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span>      []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">blockSize</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newMyHash</span>() <span style="color:#a6e22e">hash</span>.<span style="color:#a6e22e">Hash</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">myHash</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">data</span>:      make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">0</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">blockSize</span>: <span style="color:#ae81ff">64</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">h</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Write 将 p 中的数据更新进 m</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myHash</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">nn</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nn</span> = len(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span> = append(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span>, <span style="color:#ae81ff">38</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span> = append(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">p</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nn</span> = len(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> len(<span style="color:#a6e22e">p</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">nn</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Sum 后面追加</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myHash</span>) <span style="color:#a6e22e">Sum</span>(<span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>) []<span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span> = append(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">b</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myHash</span>) <span style="color:#a6e22e">Reset</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">blockSize</span> = <span style="color:#ae81ff">64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myHash</span>) <span style="color:#a6e22e">Size</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myHash</span>) <span style="color:#a6e22e">BlockSize</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">blockSize</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newMyHashFunc</span>() <span style="color:#a6e22e">hash</span>.<span style="color:#a6e22e">Hash</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">newMyHash</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另外，对于 <code>type Content interface</code>，我们也简单实现一个：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">myContent</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newMyContent</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">myContent</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">myContent</span>(<span style="color:#a6e22e">s</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">myContent</span>) <span style="color:#a6e22e">CalculateHash</span>() ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//hash := md5.New()</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//hash.Write(c.ToBytes())</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//return hash.Sum(nil), nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> []byte(<span style="color:#a6e22e">c</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">c</span> <span style="color:#a6e22e">myContent</span>) <span style="color:#a6e22e">Equals</span>(<span style="color:#a6e22e">other</span> <span style="color:#a6e22e">merkletree</span>.<span style="color:#a6e22e">Content</span>) (<span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">DeepEqual</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">other</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="创建">创建<a hidden class="anchor" aria-hidden="true" href="#创建">#</a></h3>
<p>接下来我们提供一个构造方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">//NewTree creates a new Merkle Tree using the content cs.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewTree</span>(<span style="color:#a6e22e">cs</span> []<span style="color:#a6e22e">Content</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">defaultHashStrategy</span> = <span style="color:#a6e22e">sha256</span>.<span style="color:#a6e22e">New</span>  <span style="color:#75715e">// 默认使用 sha256.New 进行哈希</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MerkleTree</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">hashStrategy</span>: <span style="color:#a6e22e">defaultHashStrategy</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">leafs</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buildWithContent</span>(<span style="color:#a6e22e">cs</span>, <span style="color:#a6e22e">t</span>)  <span style="color:#75715e">// 逐层构建结点</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Root</span> = <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Leafs</span> = <span style="color:#a6e22e">leafs</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">merkleRoot</span> = <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Hash</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">t</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// NewTreeWithHashStrategy 效果同 NewTree，不过使用自定义的哈希函数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">NewTreeWithHashStrategy</span>(<span style="color:#a6e22e">cs</span> []<span style="color:#a6e22e">Content</span>, <span style="color:#a6e22e">hashStrategy</span> <span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">hash</span>.<span style="color:#a6e22e">Hash</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MerkleTree</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">hashStrategy</span>: <span style="color:#a6e22e">hashStrategy</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">leafs</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buildWithContent</span>(<span style="color:#a6e22e">cs</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Root</span> = <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Leafs</span> = <span style="color:#a6e22e">leafs</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">merkleRoot</span> = <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Hash</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">t</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着我们来看 <code>buildWithContent</code> 做了什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// buildWithContent 主要将 Content 转变成 Node，为下一步的逐层构建做好准备</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildWithContent</span>(<span style="color:#a6e22e">cs</span> []<span style="color:#a6e22e">Content</span>, <span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>, []<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">cs</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;error: cannot construct tree with no content&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">leaves</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将当前的所有 Content 转化成 Node，放在数组 leaves 中</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">cs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">hash</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">CalculateHash</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">leaves</span> = append(<span style="color:#a6e22e">leaves</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Hash</span>: <span style="color:#a6e22e">hash</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">C</span>:    <span style="color:#a6e22e">c</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">leaf</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Tree</span>: <span style="color:#a6e22e">t</span>,
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buildIntermediate</span>(<span style="color:#a6e22e">leaves</span>, <span style="color:#a6e22e">t</span>)  <span style="color:#75715e">// 逐层构建默克尔树，最后返回树根</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">leaves</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再看 <code>buildIntermediate</code> 如何逐层构建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">buildIntermediate</span>(<span style="color:#a6e22e">nl</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>, <span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">nodes</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 如果是单数，不复制自己以凑成对，而是使自己的父节点只有一个左孩子结点(自己)，没有右孩子结点</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">nl</span>); <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">hashStrategy</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">chash</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> len(<span style="color:#a6e22e">nl</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 单数个，父节点计算哈希时只计算左孩子的</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">chash</span> = <span style="color:#a6e22e">nl</span>[<span style="color:#a6e22e">left</span>].<span style="color:#a6e22e">Hash</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 双数个，父节点从左右子孩子的哈希计算得到自己的哈希</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">chash</span> = append(<span style="color:#a6e22e">nl</span>[<span style="color:#a6e22e">left</span>].<span style="color:#a6e22e">Hash</span>, <span style="color:#a6e22e">nl</span>[<span style="color:#a6e22e">right</span>].<span style="color:#a6e22e">Hash</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">chash</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 生成父节点</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">node</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Left</span>: <span style="color:#a6e22e">nl</span>[<span style="color:#a6e22e">left</span>],
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Hash</span>: <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Sum</span>(<span style="color:#66d9ef">nil</span>),
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">Tree</span>: <span style="color:#a6e22e">t</span>,
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &lt; len(<span style="color:#a6e22e">nl</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span> = <span style="color:#a6e22e">nl</span>[<span style="color:#a6e22e">right</span>]
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nodes</span> = append(<span style="color:#a6e22e">nodes</span>, <span style="color:#a6e22e">node</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">right</span> &lt; len(<span style="color:#a6e22e">nl</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">node</span>.<span style="color:#a6e22e">Right</span>.<span style="color:#a6e22e">Parent</span> = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">nl</span>[<span style="color:#a6e22e">left</span>].<span style="color:#a6e22e">Parent</span> = <span style="color:#a6e22e">node</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果只有两个，说明当前构造的 node 就是根节点，结束递归</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">nl</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 递归调用</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">buildIntermediate</span>(<span style="color:#a6e22e">nodes</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="打印">打印<a hidden class="anchor" aria-hidden="true" href="#打印">#</a></h3>
<p>为了方便调试，我们先实现反序列化默克尔树——逐层遍历二叉树。逐层遍历二叉树是数据结构课程中的基础操作，需要用到一个队列，我们先实现一个简单的队列：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">queue</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> []<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">newQueue</span>() <span style="color:#a6e22e">queue</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">queue</span>{<span style="color:#a6e22e">data</span>: make([]<span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>, <span style="color:#ae81ff">0</span>)}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">q</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 入队</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">queue</span>) <span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span> = append(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span>, <span style="color:#a6e22e">c</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 出队</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">queue</span>) <span style="color:#a6e22e">dequeue</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 是否为空</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">queue</span>) <span style="color:#a6e22e">isEmpty</span>() <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 队列中元素个数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">q</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">queue</span>) len() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">data</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>借助队列实现默克尔树的打印：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Print 打印默克尔树</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) <span style="color:#a6e22e">Print</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Leafs</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;empty tree&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newQueue</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Root</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">isEmpty</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">size</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span>.len()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">size</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">tmp</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">dequeue</span>()
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tmp</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">leaf</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;hash(%s)   &#34;</span>, <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Hash</span>)
</span></span><span style="display:flex;"><span>			} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;hash(%s)    &#34;</span>, <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Hash</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Left</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">q</span>.<span style="color:#a6e22e">enqueue</span>(<span style="color:#a6e22e">tmp</span>.<span style="color:#a6e22e">Right</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Print</span>(<span style="color:#e6db74">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="查找">查找<a hidden class="anchor" aria-hidden="true" href="#查找">#</a></h3>
<p>先看实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// 查找 content 对应的从上到下的路径，index 表示是否为左孩子</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) <span style="color:#a6e22e">GetMerklePath</span>(<span style="color:#a6e22e">content</span> <span style="color:#a6e22e">Content</span>) ([][]<span style="color:#66d9ef">byte</span>, []<span style="color:#66d9ef">int64</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">current</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Leafs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ok</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">Equals</span>(<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">currentParent</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">Parent</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">merklePath</span> [][]<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">index</span> []<span style="color:#66d9ef">int64</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">currentParent</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 当前节点是父节点的右孩子</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Right</span>.<span style="color:#a6e22e">Hash</span>, <span style="color:#a6e22e">current</span>.<span style="color:#a6e22e">Hash</span>) {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">merklePath</span> = append(<span style="color:#a6e22e">merklePath</span>, <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Right</span>.<span style="color:#a6e22e">Hash</span>)
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">index</span> = append(<span style="color:#a6e22e">index</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">merklePath</span> = append(<span style="color:#a6e22e">merklePath</span>, <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Left</span>.<span style="color:#a6e22e">Hash</span>)
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">index</span> = append(<span style="color:#a6e22e">index</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">current</span> = <span style="color:#a6e22e">currentParent</span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">currentParent</span> = <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Parent</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// 添加 root</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">merklePath</span>) &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Equal</span>(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Root</span>.<span style="color:#a6e22e">Left</span>.<span style="color:#a6e22e">Hash</span>, <span style="color:#a6e22e">merklePath</span>[<span style="color:#ae81ff">0</span>]) {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">index</span> = append(<span style="color:#a6e22e">index</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>				} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">index</span> = append(<span style="color:#a6e22e">index</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">merklePath</span> = append(<span style="color:#a6e22e">merklePath</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Root</span>.<span style="color:#a6e22e">Hash</span>)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">merklePath</span>, <span style="color:#a6e22e">index</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="验证证明">验证(证明)<a hidden class="anchor" aria-hidden="true" href="#验证证明">#</a></h3>
<p>首先验证一棵默克尔树是否是有效的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) <span style="color:#a6e22e">VerifyTree</span>() (<span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">calculatedMerkleRoot</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Root</span>.<span style="color:#a6e22e">verifyNode</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重新根据各个结点构建一棵默克尔树，并得到其 root，看是否与已存在的相同</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">merkleRoot</span>, <span style="color:#a6e22e">calculatedMerkleRoot</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) <span style="color:#a6e22e">verifyNode</span>() ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">leaf</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">CalculateHash</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rightBytes</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">leftBytes</span>  []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">err</span>        <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 递归处理</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rightBytes</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Right</span>.<span style="color:#a6e22e">verifyNode</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">leftBytes</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Left</span>.<span style="color:#a6e22e">verifyNode</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Tree</span>.<span style="color:#a6e22e">hashStrategy</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Write</span>(append(<span style="color:#a6e22e">leftBytes</span>, <span style="color:#a6e22e">rightBytes</span><span style="color:#f92672">...</span>)); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Sum</span>(<span style="color:#66d9ef">nil</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再次验证某个 <code>Content</code> 是否属于这棵树(零知识证明)：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) <span style="color:#a6e22e">VerifyContent</span>(<span style="color:#a6e22e">content</span> <span style="color:#a6e22e">Content</span>) (<span style="color:#66d9ef">bool</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Leafs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ok</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">Equals</span>(<span style="color:#a6e22e">content</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// 存在于已知的节点中</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 逐层计算 hash，并比较</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">currentParent</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Parent</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">currentParent</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">hashStrategy</span>()
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">allBytes</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">leftBytes</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Left</span>.<span style="color:#a6e22e">calculateNodeHash</span>()
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">allBytes</span> = <span style="color:#a6e22e">leftBytes</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">rightBytes</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Right</span>.<span style="color:#a6e22e">calculateNodeHash</span>()
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>					<span style="color:#a6e22e">allBytes</span> = append(<span style="color:#a6e22e">allBytes</span>, <span style="color:#a6e22e">rightBytes</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">allBytes</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Compare</span>(<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Sum</span>(<span style="color:#66d9ef">nil</span>), <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Hash</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">currentParent</span> = <span style="color:#a6e22e">currentParent</span>.<span style="color:#a6e22e">Parent</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>, <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// calculateNodeHash 计算当前 node 的哈希(左右孩子哈希值组合后，再求哈希)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Node</span>) <span style="color:#a6e22e">calculateNodeHash</span>() ([]<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">leaf</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">CalculateHash</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Tree</span>.<span style="color:#a6e22e">hashStrategy</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">allBytes</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">allBytes</span> = <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Left</span>.<span style="color:#a6e22e">Hash</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">allBytes</span> = append(<span style="color:#a6e22e">allBytes</span>, <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">Right</span>.<span style="color:#a6e22e">Hash</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">allBytes</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">Sum</span>(<span style="color:#66d9ef">nil</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="重建">重建<a hidden class="anchor" aria-hidden="true" href="#重建">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// RebuildTree 根据保存的文件块(leaves)重新构建默克尔树</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) <span style="color:#a6e22e">RebuildTree</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cs</span> []<span style="color:#a6e22e">Content</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Leafs</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">cs</span> = append(<span style="color:#a6e22e">cs</span>, <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">C</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">leafs</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buildWithContent</span>(<span style="color:#a6e22e">cs</span>, <span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Root</span> = <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Leafs</span> = <span style="color:#a6e22e">leafs</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">merkleRoot</span> = <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Hash</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>也可以根据提供的 <code>[]Content</code> 重新构建：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// RebuildTreeWith 根据提供的 content 完全重建一棵树</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MerkleTree</span>) <span style="color:#a6e22e">RebuildTreeWith</span>(<span style="color:#a6e22e">cs</span> []<span style="color:#a6e22e">Content</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">root</span>, <span style="color:#a6e22e">leafs</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">buildWithContent</span>(<span style="color:#a6e22e">cs</span>, <span style="color:#a6e22e">m</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Root</span> = <span style="color:#a6e22e">root</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Leafs</span> = <span style="color:#a6e22e">leafs</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">merkleRoot</span> = <span style="color:#a6e22e">root</span>.<span style="color:#a6e22e">Hash</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="四参考文档">四、参考文档<a hidden class="anchor" aria-hidden="true" href="#四参考文档">#</a></h2>
<ul>
<li><a href="https://github.com/yeasy/blockchain_guide/blob/master/05_crypto/merkle_trie.md">Merkle 树结构</a></li>
<li><a href="https://blog.csdn.net/wo541075754/article/details/54632929">Merkle Tree（默克尔树）算法解析</a></li>
<li><a href="https://github.com/cbergoon/merkletree">go 语言实现的 merkle 树 我修改了部分实现</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/">默克尔树</a></li>
      <li><a href="http://localhost:1313/tags/merkletree/">MerkleTree</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">hujm2023&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
