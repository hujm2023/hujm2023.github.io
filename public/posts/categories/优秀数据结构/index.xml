<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>优秀数据结构 on hujm2023&#39;s blog</title>
    <link>http://localhost:1313/categories/%E4%BC%98%E7%A7%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 优秀数据结构 on hujm2023&#39;s blog</description>
    <generator>Hugo -- 0.151.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 13 May 2021 21:08:09 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/categories/%E4%BC%98%E7%A7%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>最小堆以及优先级队列的Golang实现</title>
      <link>http://localhost:1313/posts/%E6%9C%80%E5%B0%8F%E5%A0%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84golang%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 13 May 2021 21:08:09 +0800</pubDate>
      <guid>http://localhost:1313/posts/%E6%9C%80%E5%B0%8F%E5%A0%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%9A%84golang%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D&#34;&gt;堆&lt;/a&gt;，是计算机科学中的一种特别的完全二叉树。若父节点的值恒小于等于子节点的值，此堆称为&lt;strong&gt;最小堆（min heap）&lt;/strong&gt;；反之，若母节点的值恒大于等于子节点的值，此堆称为&lt;strong&gt;最大堆（max heap）&lt;/strong&gt;。在堆中最顶端的那一个节点，称作 &lt;strong&gt;根节点（root node）&lt;/strong&gt;，根节点本身没有 &lt;strong&gt;父节点（parent node）&lt;/strong&gt;。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>优秀数据结构--默克尔树</title>
      <link>http://localhost:1313/posts/%E4%BC%98%E7%A7%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/</link>
      <pubDate>Thu, 22 Oct 2020 15:21:59 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E4%BC%98%E7%A7%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/</guid>
      <description>&lt;h2 id=&#34;一简介&#34;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Merkle_tree&#34;&gt;默克尔树&lt;/a&gt;是一种典型的二叉树结构，由&lt;strong&gt;一个根节点&lt;/strong&gt;、&lt;strong&gt;一组中间节点&lt;/strong&gt; 和 &lt;strong&gt;一组叶节点&lt;/strong&gt; 组成。默克尔树最早由 &lt;code&gt;Merkle Ralf &lt;/code&gt;在 1980 年提出，曾广泛用于 &lt;strong&gt;文件系统&lt;/strong&gt; 和 &lt;strong&gt;P2P&lt;/strong&gt; 系统中，比如 &lt;code&gt;Git&lt;/code&gt;、区块链、&lt;code&gt;IPFS&lt;/code&gt; 等大名鼎鼎的项目或技术。&lt;/p&gt;
&lt;p&gt;他又被称为 &lt;strong&gt;哈希树&lt;/strong&gt;，即存储哈希值的树。树的叶子结点是 &lt;strong&gt;数据块&lt;/strong&gt;(文件或者对象)的哈希值，而非叶子结点保存的是其子节点连接起来后的哈希值。简单来说，它有以下特点：&lt;/p&gt;</description>
    </item>
    <item>
      <title>跳表原理以及Golang实现</title>
      <link>http://localhost:1313/posts/%E8%B7%B3%E8%A1%A8/</link>
      <pubDate>Mon, 05 Oct 2020 05:32:24 +0000</pubDate>
      <guid>http://localhost:1313/posts/%E8%B7%B3%E8%A1%A8/</guid>
      <description>&lt;h2 id=&#34;一前言&#34;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;大家应该对 &lt;strong&gt;二分查找算法&lt;/strong&gt; 不陌生，二分查找之所以能达到 &lt;code&gt;O(logN)&lt;/code&gt; 的时间复杂度，一个重要原因在于它所依赖的数据结构是数组，数组支持随机访问，可通过下标很容易地定位到中间的某个元素。但是链表就没有 &lt;strong&gt;随机访问数据&lt;/strong&gt; 这个特性，要判断是否包含某个元素，只能从头开始遍历对比。但是数组有数组的局限性，比如需要连续的内存空间，插入删除操作会引起数组的扩容和元素移动；链表有链表的优势，链表不需要先申请连续的空间，插入删除操作的效率非常高。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
