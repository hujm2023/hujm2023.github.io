<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Redis源码阅读--1.基础数据结构与对象 | hujm2023&#39;s blog</title>
<meta name="keywords" content="Redis, 基础数据结构">
<meta name="description" content="首先明确，Redis 是一个使用 C 语言编写的键值对存储系统。Redis 是众所周知的 “快”，一方面，它是一个内存数据库，所有的操作都是在内存中完成的，内存的访问速度本身就很快；另一方面，得益于它底层的数据结构。Redis 的常见类型可在这个网页找到：Redis 命令参考简体中文版，其使用到的底层数据结构有如下六种：简单动态字符串、双向链表、压缩列表、哈希表、跳表和 整数数组。本篇文章，将具体了解这些底层数据结构的实现。">
<meta name="author" content="JemmyHu(hujm20151021@gmail.com)">
<link rel="canonical" href="http://localhost:1313/posts/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css" integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn&#43;yY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-1-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="hujm2023&#39;s blog (Alt + H)">hujm2023&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Redis源码阅读--1.基础数据结构与对象
    </h1>
    <div class="post-meta"><span title='2020-10-02 12:31:41 +0000 UTC'>October 2, 2020</span>&nbsp;·&nbsp;<span>JemmyHu(hujm20151021@gmail.com)</span>

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="https://pic.downk.cc/item/5f76adca160a154a674bc4da.png" alt="">
        
</figure>
  <div class="post-content"><p>首先明确，<code>Redis</code> 是一个<strong>使用 C 语言编写的键值对存储系统</strong>。<code>Redis</code> 是众所周知的 “<strong>快</strong>”，一方面，它是一个内存数据库，所有的操作都是在<strong>内存</strong>中完成的，内存的访问速度本身就很快；另一方面，得益于它<strong>底层的数据结构</strong>。<code>Redis</code> 的常见类型可在这个网页找到：<a href="https://redis.readthedocs.io/en/2.4/index.html">Redis 命令参考简体中文版</a>，其使用到的底层数据结构有如下六种：<strong>简单动态字符串</strong>、<strong>双向链表</strong>、<strong>压缩列表</strong>、<strong>哈希表</strong>、<strong>跳表</strong>和 <strong>整数数组</strong>。本篇文章，将具体了解这些底层数据结构的实现。</p>
<blockquote>
<p>本文所涉及源码位于：<a href="https://github.com/redis/redis">https://github.com/redis/redis</a>，所选版本为 <strong>6.0.8</strong>。</p>
<p>绘图工具为 <a href="draw.io">draw.io</a></p>
<p>涉及到内存操作的函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">size_t</span> size); <span style="color:#75715e">// 调用zmalloc函数，申请size大小的空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zcalloc</span>(<span style="color:#66d9ef">size_t</span> size); <span style="color:#75715e">// 调用系统函数calloc申请内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zrealloc</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr, <span style="color:#66d9ef">size_t</span> size); <span style="color:#75715e">// 原内存重新调整为size空间的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr);  <span style="color:#75715e">// 调用zfree释放内存空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">zstrdup</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s); <span style="color:#75715e">// 字符串复制方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">zmalloc_used_memory</span>(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">// 获取当前以及占用的内存空间大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zmalloc_enable_thread_safeness</span>(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">// 是否设置线程安全模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zmalloc_set_oom_handler</span>(<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>oom_handler)(<span style="color:#66d9ef">size_t</span>)); <span style="color:#75715e">// 可自定义设置内存溢出的处理方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">zmalloc_get_fragmentation_ratio</span>(<span style="color:#66d9ef">size_t</span> rss); <span style="color:#75715e">// 获取所给内存和已使用内存的大小之比
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">zmalloc_get_rss</span>(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">// 获取RSS信息(Resident Set Size)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">zmalloc_get_private_dirty</span>(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">// 获得实际内存大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">zmalloc_get_smap_bytes_by_field</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>field); <span style="color:#75715e">// 获取/proc/self/smaps字段的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">size_t</span> <span style="color:#a6e22e">zmalloc_get_memory_size</span>(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">// 获取物理内存大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zlibc_free</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr); <span style="color:#75715e">// 原始系统free释放方法
</span></span></span></code></pre></div></blockquote>
<h2 id="一底层数据结构">一、底层数据结构<a hidden class="anchor" aria-hidden="true" href="#一底层数据结构">#</a></h2>
<h3 id="1-简单动态字符串">1. 简单动态字符串<a hidden class="anchor" aria-hidden="true" href="#1-简单动态字符串">#</a></h3>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/sds.h">sds.h</a></p></blockquote>
<h4 id="11-数据结构">1.1 数据结构<a hidden class="anchor" aria-hidden="true" href="#11-数据结构">#</a></h4>
<p><strong>SDS（Simple Dynamic Strings, 简单动态字符串）是 Redis 的一种基本数据结构，主要是用于存储字符串和整数。</strong> 在 <code>Redis 3.2</code> 版本以前，<code>SDS</code> 的实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> sdshdr {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 记录 buf 数组中未使用字节的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> free;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 字节数组，用于保存字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>比如，字符串 <code>Redis6.0</code> 的结构如下：</p>
<p><img alt="带有未使用空间的SDS" loading="lazy" src="https://pic.downk.cc/item/5f768cb7160a154a67445538.png"></p>
<p><code>SDS</code> 遵循 <strong><code>C</code> 字符串以空字符结尾</strong>的惯例， 但保存空字符的 <code>1</code> 字节空间不计算在 SDS 的 <code>len</code> 属性里面， 并且为空字符分配额外的 <code>1</code> 字节空间， 以及添加空字符到字符串末尾等操作都是由 <code>SDS</code> 函数自动完成的， 所以这个空字符对于 <code>SDS</code> 的使用者来说是完全透明的——这样做的好处是，<code>SDS</code> 可以直接使用 <code>C</code> 库中的有关字符串的函数。</p>
<p>但是在 <code>Redis 3.2</code> 以后，为了提高效率以及更加节省内存，<code>Redis</code> 将 <code>SDS</code> 划分成一下五种类型：</p>
<ul>
<li><code>sdshdr5</code></li>
<li><code>sdshdr8</code></li>
<li><code>sdshdr16</code></li>
<li><code>sdshdr32</code></li>
<li><code>sdshdr64</code></li>
</ul>
<p>先看 <code>sdshdr5</code>，增加了一个 <code>flags</code> 字段来标识类型，用一个字节(8 位)来存储：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Note: sdshdr5 is never used, we just access the flags byte directly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr5 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; <span style="color:#75715e">/* 前 3 位表示类型, 后 5 为表示长度 */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>对于 <code>sdshdr5</code> ，因为其可存储长度最大为 <code>2^5 - 1 = 31</code>，当字符串长度超过 31 时，仅靠 <code>flag</code> 的后 5 为表示长度是不够的，这时需要使用其他的四个结构来保存：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr8 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> len;                <span style="color:#75715e">// 已使用长度 1字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> alloc;              <span style="color:#75715e">// 总长度 1字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags;        <span style="color:#75715e">// 前 3 位表示存储类型，后 5 位 预留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr16 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint16_t</span> len;               <span style="color:#75715e">// 已使用长度 2字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint16_t</span> alloc;             <span style="color:#75715e">// 总长度 2字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags;        <span style="color:#75715e">// 前 3 位表示存储类型，后 5 位 预留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr32 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> len;               <span style="color:#75715e">// 已使用长度 4字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> alloc;             <span style="color:#75715e">// 总长度 4字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags;        <span style="color:#75715e">// 前 3 位表示存储类型，后 5 位 预留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr64 {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> len;               <span style="color:#75715e">// 已使用长度 8字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> alloc;             <span style="color:#75715e">// 总长度 8字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags;        <span style="color:#75715e">// 前 3 位表示存储类型，后 5 位 预留
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><blockquote>
<p>C/C++ 中 <code>__packed</code> 的作用：</p>
<p>假设有以下结构体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">char</span> a;      <span style="color:#75715e">// 1 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">int</span> b;       <span style="color:#75715e">// 4 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">char</span> c[<span style="color:#ae81ff">2</span>];   <span style="color:#75715e">// 2 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">double</span> d;    <span style="color:#75715e">// 8 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}Struct_A;
</span></span></code></pre></div><p>在计算机内存中，<strong>结构体变量的存储通常是按字长对齐的</strong>，比如在 8 位机上，就按照 1 字节(8 位)对齐，上述结构体占用 <code>1+4+2+8=15​</code> 字节的内存；在 16 位机上，按照 2 字节对齐，则该结构体占用 <code>2+4+2+8=16​</code> 字节。也就是说，在更高位的机器中，如果按照默认的机器字长做内存对齐的标准，那总会有一些空间是浪费的，比如上面 16 位时，为了对齐，使用了 2 字节来存储一个<code>char</code>类型的变量。为什么要对齐？这是因为对内存操作按照整字存取会有更高的效率，是 “以空间换时间” 的思想体现。当然，在空间更优先的情况下，也可以不使用默认的机器字长做内存对齐，这个时候，使用 <code>__packed___</code>关键字，可以强制使编译器将结构体成员按照 1 字节进行内存对齐，可以得到非对齐的紧凑型结构体。</p></blockquote>
<h4 id="12-api">1.2 API<a hidden class="anchor" aria-hidden="true" href="#12-api">#</a></h4>
<ul>
<li><strong>创建 SDS</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Create a new sds string starting from a null terminated C string. */</span>
</span></span><span style="display:flex;"><span>sds <span style="color:#a6e22e">sdsnew</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>init) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> initlen <span style="color:#f92672">=</span> (init <span style="color:#f92672">==</span> NULL) <span style="color:#f92672">?</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">:</span> <span style="color:#a6e22e">strlen</span>(init);  <span style="color:#75715e">// 拿到要创建的字符串的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sdsnewlen</span>(init, initlen);  <span style="color:#75715e">// 传入字符串、字符串长度，调用 sdsnewlen 动态分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>sds <span style="color:#a6e22e">sdsnewlen</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>init, <span style="color:#66d9ef">size_t</span> initlen) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>sh;
</span></span><span style="display:flex;"><span>    sds s;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> type <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdsReqType</span>(initlen);  <span style="color:#75715e">// 根据字符串长度得到合适的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 一般情况下，创建一个空字符串的目的都是为了后面的append操作，因此，空字符串的情况下，直接创建SDS_TYPE_8，减少后面的扩容操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> SDS_TYPE_5 <span style="color:#f92672">&amp;&amp;</span> initlen <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) type <span style="color:#f92672">=</span> SDS_TYPE_8;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算类型对应的结构体头部长度(len alloc flags的长度)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> hdrlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdsHdrSize</span>(type);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 指向flag的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>fp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 申请内存，内存大小为 结构体头部长度+字符串长度(buf)+1，这里+1是因为要考虑 &#39;\0&#39; 字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sh <span style="color:#f92672">=</span> <span style="color:#a6e22e">s_malloc</span>(hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (sh <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (init<span style="color:#f92672">==</span>SDS_NOINIT)
</span></span><span style="display:flex;"><span>        init <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>init)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memset</span>(sh, <span style="color:#ae81ff">0</span>, hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将s指向buf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)sh<span style="color:#f92672">+</span>hdrlen;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 s-1 指向flag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fp <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)s)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对sds结构体变量进行赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span>(type) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> SDS_TYPE_5: {
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type <span style="color:#f92672">|</span> (initlen <span style="color:#f92672">&lt;&lt;</span> SDS_TYPE_BITS);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> SDS_TYPE_8: {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">SDS_HDR_VAR</span>(<span style="color:#ae81ff">8</span>,s);
</span></span><span style="display:flex;"><span>            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
</span></span><span style="display:flex;"><span>            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (initlen <span style="color:#f92672">&amp;&amp;</span> init)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memcpy</span>(s, init, initlen);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在s的最后添加&#39;\0&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s[initlen] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回指向 buf 数组的指针s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>注意，创建 <code>SDS</code> 时返回给上层的是指向 <code>buf</code> 数组的指针 s，而不是结构体的指针，那如何找到结构体中的其他元素呢？上面提到了 <code>__packed__</code> 关键字，使用 1 字节进行内存对齐，那么知道了 <code>buf</code> 的地址，将其减去对应类型的长度(偏移量)，就能得到结构体中其他类型的地址。</p>
<ul>
<li><strong>清空 SDS</strong></li>
</ul>
<p>清空一个 <code>SDS</code> 有两个途径：</p>
<p>第一种是直接调用 <code>s_free()</code> 函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Free an sds string. No operation is performed if &#39;s&#39; is NULL. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sdsfree</span>(sds s) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s_free</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)s<span style="color:#f92672">-</span><span style="color:#a6e22e">sdsHdrSize</span>(s[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>另一种方式是 <strong>重置 len 为 0</strong> 的方式，这种情况下 <code>buf</code> 所占用的空间并没有被清除掉，新的数据会直接覆盖 <code>buf</code> 中的原有数据而无需再申请新的内存空间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Modify an sds string in-place to make it empty (zero length).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * However all the existing buffer is not discarded but set as free space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * so that next append operations will not require allocations up to the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * number of bytes previously available. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sdsclear</span>(sds s) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sdssetlen</span>(s, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    s[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>拼接 SDS</strong></li>
</ul>
<p>拼接使用的是 <code>sds sdscatsds(sds s, sds t)</code>，但最终调用的还是 <code>sdscatlen</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 将 t 拼接到 s 后面。调用此方法之后，sds底层的buf可能经过了扩容迁移了原来的位置，注意更新原来变量中对应的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sds <span style="color:#a6e22e">sdscatsds</span>(sds s, <span style="color:#66d9ef">const</span> sds t) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sdscatlen</span>(s, t, <span style="color:#a6e22e">sdslen</span>(t));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>sds <span style="color:#a6e22e">sdscatlen</span>(sds s, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>t, <span style="color:#66d9ef">size_t</span> len) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> curlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdslen</span>(s);  <span style="color:#75715e">// 计算当前s的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdsMakeRoomFor</span>(s,len);  <span style="color:#75715e">// 空间不够的话扩容，确保s的剩余空间足够放得下t
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> NULL; <span style="color:#75715e">// 扩容失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memcpy</span>(s<span style="color:#f92672">+</span>curlen, t, len);   <span style="color:#75715e">// 拼接
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sdssetlen</span>(s, curlen<span style="color:#f92672">+</span>len);   <span style="color:#75715e">// 更新s的属性len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s[curlen<span style="color:#f92672">+</span>len] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;       <span style="color:#75715e">// 给s最后加上 &#39;\0&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来我们详细看一下扩容规则，在函数 <code>sdsMakeRoomFor</code> 中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 将sds s的 buf 的可用空间扩大，使得调用此函数之后的s能够再多存储 addlen 长度的字符串。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 注意：此方法并未改变 sds 的len属性，仅仅改变的是 sds 的 buf 数组的空间。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sds <span style="color:#a6e22e">sdsMakeRoomFor</span>(sds s, <span style="color:#66d9ef">size_t</span> addlen) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>sh, <span style="color:#f92672">*</span>newsh;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> avail <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdsavail</span>(s);  <span style="color:#75715e">// 当前的可用空间长度：s.alloc - s.len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">size_t</span> len, newlen;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> type, oldtype <span style="color:#f92672">=</span> s[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&amp;</span> SDS_TYPE_MASK;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> hdrlen;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 情况1：剩余长度大于所需要长度，没必要扩容，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (avail <span style="color:#f92672">&gt;=</span> addlen) <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    len <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdslen</span>(s);     	<span style="color:#75715e">// 当前字符串长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sh <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)s<span style="color:#f92672">-</span><span style="color:#a6e22e">sdsHdrSize</span>(oldtype);
</span></span><span style="display:flex;"><span>    newlen <span style="color:#f92672">=</span> (len<span style="color:#f92672">+</span>addlen);    <span style="color:#75715e">// 新字符串长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 情况2：扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 情况2.1： 如果 新长度 &lt; 1MB，则按 新长度的2倍 扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    		否则，就按 新长度+1MB 扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (newlen <span style="color:#f92672">&lt;</span> SDS_MAX_PREALLOC)
</span></span><span style="display:flex;"><span>        newlen <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        newlen <span style="color:#f92672">+=</span> SDS_MAX_PREALLOC;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算新长度的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    type <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdsReqType</span>(newlen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 还是为了后续使用减少扩容次数的原因，将 sdshdr5 变为 sdshdr8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> SDS_TYPE_5) type <span style="color:#f92672">=</span> SDS_TYPE_8;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    hdrlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">sdsHdrSize</span>(type);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (oldtype<span style="color:#f92672">==</span>type) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果新长度对应的类型没变，则直接调用 s_realloc 扩大动态数组即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        newsh <span style="color:#f92672">=</span> <span style="color:#a6e22e">s_realloc</span>(sh, hdrlen<span style="color:#f92672">+</span>newlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (newsh <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)newsh<span style="color:#f92672">+</span>hdrlen;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Since the header size changes, need to move the string forward,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * and can&#39;t use realloc */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 类型发生了改变，意味着sds结构体头部的三个属性的类型也要跟着变化，此时直接重新申请一块内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        newsh <span style="color:#f92672">=</span> <span style="color:#a6e22e">s_malloc</span>(hdrlen<span style="color:#f92672">+</span>newlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (newsh <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 原s的数据拷贝到新的内存上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">memcpy</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)newsh<span style="color:#f92672">+</span>hdrlen, s, len<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 释放掉原来的s的空间，并将其更新为刚才新申请的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">s_free</span>(sh);
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)newsh<span style="color:#f92672">+</span>hdrlen;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新 flag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        s[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> type;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新 len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">sdssetlen</span>(s, len);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新 alloc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">sdssetalloc</span>(s, newlen);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>代码中注释已经很清楚了，这里再总结一下扩容策略：如果 <code>剩余长度 avail</code> &gt;= <code>新增长度 addlen</code> ，则无需扩容；否则，如果 <code>avail + addlen &lt; 1MB</code>，按照 <code>2 * (avail + addlen)</code>扩容，否则按照 <code>avail + addlen + 1MB</code> 扩容。</p>
<h4 id="13-总结">1.3 总结<a hidden class="anchor" aria-hidden="true" href="#13-总结">#</a></h4>
<ul>
<li>创建 <code>SDS</code> 时返回的是指向 <code>buf</code> 数组的指针，而不是 <code>SDS</code> 类型的对象，这样的好处是兼容了已有的 C 语言中的相关函数；</li>
<li>读取内容时，先通过类对应类型计算偏移量，再通过 <code>len</code> 属性来限制读取的长度，杜绝了缓冲区溢出，二进制安全；</li>
<li>根据字符串的长度，定义了五种不同的类型，节省了空间；</li>
<li>进行字符串拼接时，会通过 <code>sdsMakeRoomFor</code> 函数来决定是否有底层 <code>buf</code> 数组的扩容操作。</li>
</ul>
<h3 id="2-双端链表">2. 双端链表<a hidden class="anchor" aria-hidden="true" href="#2-双端链表">#</a></h3>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/adlist.h">adlist.h</a></p></blockquote>
<h4 id="21-数据结构">2.1 数据结构<a hidden class="anchor" aria-hidden="true" href="#21-数据结构">#</a></h4>
<p>当我们使用 <code>lpush</code> 或者 <code>rpush</code> 的时候，其实底层对应的数据结构就是一个双端链表。</p>
<p>首先我们来了解结点 <code>listNode</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> listNode {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> listNode <span style="color:#f92672">*</span>prev;  <span style="color:#75715e">// 头指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> listNode <span style="color:#f92672">*</span>next;  <span style="color:#75715e">// 尾指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value;    		<span style="color:#75715e">// 具体的值，因为值的类型不确定，此处使用万能指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} listNode;
</span></span></code></pre></div><p>虽然使用多个 <code>listNode</code>就已经足够表示一个双端链表，但是为了更方便，<code>Redis</code> 还有如下结构：</p>
<pre tabindex="0"><code>typedef struct list {
    listNode *head;  // 头指针
    listNode *tail;  // 尾指针
    void *(*dup)(void *ptr);  // 拷贝结点函数
    void (*free)(void *ptr);  // 释放结点值函数
    int (*match)(void *ptr, void *key); // 判断两个结点是否相等的函数
    unsigned long len;  // 链表长度
} list;
</code></pre><p>他们的关系可用如下图表示：</p>
<p><img alt="Redis双端链表" loading="lazy" src="https://pic.downk.cc/item/5f769152160a154a6745655b.png"></p>
<h4 id="22-api">2.2 API<a hidden class="anchor" aria-hidden="true" href="#22-api">#</a></h4>
<ul>
<li><strong>创建 <code>list</code> 对象</strong></li>
</ul>
<p>创建的是一个 <code>list</code> 对象，首先会尝试申请分配空间，失败返回 <code>NULL</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 创建的只是一个 list 对象，这个对象可以被 AlFreeList() 释放掉，但是仅仅释放的是这个 list 对象，其上面的 listNode 对象还需要另外手动释放
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>list <span style="color:#f92672">*</span><span style="color:#a6e22e">listCreate</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> list <span style="color:#f92672">*</span>list;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 申请分配内存，失败返回 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((list <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>list))) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 给其他属性赋值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>dup <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>free <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>match <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 最终返回 list 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>添加元素 <code>listNode</code> 到 <code>list</code></strong></li>
</ul>
<p>给一个带头的双向链表添加元素，有三种添加方法：<strong>头插入</strong> 、 <strong>尾插入</strong> 和 指定位置，分别对应的操作为 <code>lpush</code> 、<code>rpush</code> 和 <code>linsert</code>。对于 <code>lpush</code> 和 <code>rpush</code> 的实现如下，本质上就是对双端链表的基础操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>list <span style="color:#f92672">*</span><span style="color:#a6e22e">listAddNodeHead</span>(list <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// 申请分配内存，失败返回 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((node <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>node))) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 listNode 插入到 list 的元素中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果之前 list 没有元素，那么 list 的 head 和 tail 均指向当前的 listNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 链表的头插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>head<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新 len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    list<span style="color:#f92672">-&gt;</span>len<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回的是传进来的 list ，失败返回的是 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 尾插入，过程和头插入类似
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>list <span style="color:#f92672">*</span><span style="color:#a6e22e">listAddNodeTail</span>(list <span style="color:#f92672">*</span>list, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((node <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>node))) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>tail;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>tail<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>len<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>关于 <code>linsert</code> ，其用法如下：</p>
<blockquote>
<p><strong><code>LINSERT key BEFORE|AFTER pivot value</code></strong></p>
<p>将值<code>value</code>插入到列表<code>key</code>当中，位于值<code>pivot</code>之前或之后。</p>
<p>当<code>pivot</code>不存在于列表<code>key</code>时，不执行任何操作。</p>
<p>当<code>key</code>不存在时，<code>key</code>被视为空列表，不执行任何操作。</p>
<p>如果<code>key</code>不是列表类型，返回一个错误。</p></blockquote>
<p>在 <code>Redis</code> 底层，对应的方法为 <code>listInsertNode</code>，当然，为了找到 <code>old_node</code>，前面还需要遍历 <code>list</code>，这个操作的时间复杂度是 <code>O(n)</code>，我们这里只关注如何插入元素：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 在 list 的 old_node 的前或后(after&lt;0,在前面增加；after&gt;0，在后面增加)新增值为 value 的新listNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>list <span style="color:#f92672">*</span><span style="color:#a6e22e">listInsertNode</span>(list <span style="color:#f92672">*</span>list, listNode <span style="color:#f92672">*</span>old_node, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>value, <span style="color:#66d9ef">int</span> after) {
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>node;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新增的 listNode 申请内存，失败返回 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((node <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>node))) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    node<span style="color:#f92672">-&gt;</span>value <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (after) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// after&gt;0，在后面插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> old_node;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> old_node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">==</span> old_node) {
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// after&lt;0，在前面插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> old_node;
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> old_node<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">==</span> old_node) {
</span></span><span style="display:flex;"><span>            list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新 len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    list<span style="color:#f92672">-&gt;</span>len<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 成功 返回传进来的 list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> list;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>删除元素</strong></li>
</ul>
<p>删除元素的情况有以下几种：清空整个 <code>list</code> ，删除某个 <code>listNode</code>。</p>
<p>我们先看清空整个 <code>list</code> ，它只是释放掉了这个 <code>list</code> 上连的所有的 <code>listNode</code> ，而 <code>list</code> 对象并没有被销毁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Remove all the elements from the list without destroying the list itself. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listEmpty</span>(list <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> len;
</span></span><span style="display:flex;"><span>    listNode <span style="color:#f92672">*</span>current, <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    current <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>head;
</span></span><span style="display:flex;"><span>    len <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>len;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历整个链表，逐个释放空间，直到为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(len<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> current<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span>free) list<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">free</span>(current<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zfree</span>(current);
</span></span><span style="display:flex;"><span>        current <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    list<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而下面这个 <code>listRelease</code> 方法，会释放所有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Free the whole list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This function can&#39;t fail. */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listRelease</span>(list <span style="color:#f92672">*</span>list)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">listEmpty</span>(list);    <span style="color:#75715e">// 先清空所有的 listNode
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">zfree</span>(list);		<span style="color:#75715e">// 再释放 list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>然后看删除某个具体的 <code>listNode</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listDelNode</span>(list <span style="color:#f92672">*</span>list, listNode <span style="color:#f92672">*</span>node)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 是否是 list 中的第一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>prev)
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>prev<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>head <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 是否是 list 中的最后一个元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (node<span style="color:#f92672">-&gt;</span>next)
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">-&gt;</span>prev <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        list<span style="color:#f92672">-&gt;</span>tail <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>prev;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 释放当前节点的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (list<span style="color:#f92672">-&gt;</span>free) list<span style="color:#f92672">-&gt;</span><span style="color:#a6e22e">free</span>(node<span style="color:#f92672">-&gt;</span>value);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 释放内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">zfree</span>(node);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新 len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    list<span style="color:#f92672">-&gt;</span>len<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="23-总结">2.3 总结<a hidden class="anchor" aria-hidden="true" href="#23-总结">#</a></h4>
<ul>
<li>
<p><code>Redis</code> 基于双端链表，可以提供各种功能：列表键、发布订阅功能、监视器等；</p>
</li>
<li>
<p>因为链表表头节点的前置节点和表尾节点的后置节点都指向 <code>NULL</code> ， 所以 <code>Redis</code> 的链表实现是无环链表；</p>
</li>
<li>
<p>仔细看过源代码后会发现，这是一个典型的双端链表，其底层实现与我在《数据结构》中遇到的如出一辙，这也从侧面说明了熟悉基本的数据结构的重要性。</p>
</li>
</ul>
<h3 id="3-字典">3. 字典<a hidden class="anchor" aria-hidden="true" href="#3-字典">#</a></h3>
<p>字典，由一个个键值对构成，首先想一下，一个字典应该提供什么样的功能？键值对用来存储数据，之后还要能插入数据、修改数据、删除数据、遍历(读取)数据，字典最大的特点就是上面这些所有的操作都可以在 <code>O(1)</code> 的时间复杂度里完成。</p>
<p>比如在 <code>redis-cli</code> 中，我输入如下命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>redis&gt; set name Jemmy
</span></span></code></pre></div><p>这条命令在 <code>redis</code> 的内存中生成了一个键值对(<code>key-value</code>)，其中 <code>key</code> 是 <code>name</code>，<code>value</code> 是 <code>Jemmy</code>的字符串对象，</p>
<p><code>Redis</code> 的字典采用 <strong>哈希表</strong> 来实现。一个哈希表，你可以简单把它想成一个数组，数组中的每个元素称为一个桶，这也就对应上我们经常所说，一个哈希表由多个桶组成，每个桶中保存了键值对的数据(<strong>哈希桶中保存的值其实并不是值本身，而是一个指向实际值的指针</strong>)。</p>
<p>提到哈希，首先要关注的是哈希算法以及解决哈希冲突的方式。哈希算法的具体实现我们暂时不关心，只需要知道 <code>Redis</code> 使用的是 <a href="https://github.com/aappleby/smhasher">MurmurHash2</a>，“<strong>这个算法的优点在于：即使输入的键是有规律的，算法仍能够给出一个很好的随机分布性，计算速度也很快</strong>”；对于解决哈希冲突的方法，最常见的是 <strong>开放地址法</strong> 和 <strong>拉链法</strong>。二者实现原理在 <strong><a href="https://jemmyh.github.io/2020/09/18/golang-map-xiang-jie/">Golang-map 详解</a></strong> 中已经说过，这里不再细讲，目前只需要知道，<strong><code>Redis</code> 采用拉链法解决哈希冲突</strong>。</p>
<p>在 <code>Redis</code> 中，有以下几个概念：哈希表、哈希表结点和字典，他们的关系大致可以描述为：字典是一个全局的字典，一个字典中包含两个哈希表，一个正在使用，另一个用作扩容用；哈希表中包含多个哈希表结点。接下来我们详细看下每个结构的具体实现：</p>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/dict.h">dict.h</a></p></blockquote>
<h4 id="31-数据结构">3.1 数据结构<a hidden class="anchor" aria-hidden="true" href="#31-数据结构">#</a></h4>
<ul>
<li><strong>哈希表结点</strong></li>
</ul>
<p>哈希表节点使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictEntry {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// value，可以是指针 uint64_t int64_t double中的某一个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">uint64_t</span> u64;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int64_t</span> s64;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> d;
</span></span><span style="display:flex;"><span>    } v;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 指向另一个哈希表结点的指针，连接哈希值相同的键值对，用来解决哈希冲突
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> dictEntry <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>} dictEntry;
</span></span></code></pre></div><ul>
<li><strong>哈希表</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictht {
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#f92672">**</span>table;          <span style="color:#75715e">// dictEntry数组，dictEntry代表一个键值对
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size;         <span style="color:#75715e">// 哈希表大小(容量)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sizemask;     <span style="color:#75715e">// 值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> used;         <span style="color:#75715e">// 哈希表已有结点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} dictht;
</span></span></code></pre></div><p>下图可以表示 <strong>哈希表 <code>dictht</code></strong> 和 <strong>哈希表结点 <code>dictEntry</code></strong> 之间的关系：</p>
<p><img alt="有一个键值对的哈希表" loading="lazy" src="https://pic.downk.cc/item/5f7723fd160a154a67697c61.png"></p>
<ul>
<li><strong>字典</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dict {
</span></span><span style="display:flex;"><span>    dictType <span style="color:#f92672">*</span>type;  <span style="color:#75715e">// 类型对应的特定函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata;  <span style="color:#75715e">// 私有数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dictht ht[<span style="color:#ae81ff">2</span>];    <span style="color:#75715e">// 两个哈希表，一个正常使用，另一个用于扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> rehashidx;  <span style="color:#75715e">// rehash 索引值，扩容时使用，正常时为-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> iterators; <span style="color:#75715e">// 正在运行的迭代器的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} dict;
</span></span></code></pre></div><p>这里的 <code>type</code> 是一个指向 <code>dictType</code> 结构体的指针，而每一个 <code>dictType</code> 结构体保存了 <strong>一组用于操作特定类型键值对的函数</strong>，不同的类型有不同的操作函数，<code>privdata</code> 保存了需要传递给特定类型函数的可选参数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictType {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算哈希值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint64_t</span> (<span style="color:#f92672">*</span>hashFunction)(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 复制键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>keyDup)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 复制值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>valDup)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>obj);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 对比键是否相同的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>keyCompare)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key1, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key2);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 销毁键的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>keyDestructor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 销毁值的函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>valDestructor)(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>obj);
</span></span><span style="display:flex;"><span>} dictType;
</span></span></code></pre></div><p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>下图展示了一个普通状态(没有进行 <code>rehash</code> )的字典：</p>
<p><img alt="未扩容的字典示例" loading="lazy" src="https://pic.downk.cc/item/5f772abc160a154a676b8909.png"></p>
<h4 id="32-哈希冲突的解决方式">3.2 哈希冲突的解决方式<a hidden class="anchor" aria-hidden="true" href="#32-哈希冲突的解决方式">#</a></h4>
<p>当两个以上的键经过哈希函数计算之后，落在了哈希表数组的同一个索引上面，我们就称这些键发生了 <strong>哈希冲突(hash collision)</strong>。</p>
<p>Redis 的哈希表使用 <strong>链接法</strong>来解决键冲突： 每个哈希表节点(<code>dictEntry</code>)都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。写入时，因为没有直接指向链的最后一个元素的指针，因此为了更少的时间复杂度， <code>Redis</code> 采用的是在链表头部插入；读取时，先定位到链头，之后逐个比较值是否与所求相同，直到遍历完整个链。</p>
<p>比如上图中，在 <code>dictht.table</code> 的 3 号桶中已经存在一个键值对 <code>k1-v1</code>，此时又新加入一个键值对 <code>k2-v2</code>，经过哈希计算后正好也落在 3 号桶中，经过插入后结果如下：</p>
<p><img alt="哈希冲突示例" loading="lazy" src="https://pic.downk.cc/item/5f773530160a154a676eef06.png"></p>
<h4 id="34-rehash-细节">3.4 rehash 细节<a hidden class="anchor" aria-hidden="true" href="#34-rehash-细节">#</a></h4>
<p>当哈希表的键值对数量太多或者太少时，需要根据实际情况对哈希表的大小进行扩大或者缩小，这个过程通过 <code>rehash(重新散列)</code> 来完成。 而判断是否进行 <code>rehash</code> ，是在向哈希表插入一个键值对的时候，接下来我们通过分析源代码的方式，详细了解 <code>rehash</code> 的细节。</p>
<p>首先，添加一个新键值对，用到的是 <code>dictAdd</code> 方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Add an element to the target hash table */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictAdd</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#f92672">*</span>entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">dictAddRaw</span>(d,key,NULL);  <span style="color:#75715e">// 将键值对封装成dictEntry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>entry) <span style="color:#66d9ef">return</span> DICT_ERR;                <span style="color:#75715e">// 如果创建dictEntry，返回失败
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dictSetVal</span>(d, entry, val);                  <span style="color:#75715e">// 键不存在，则设置dictEntry结点的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> DICT_OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们接着看 <code>dictAddRaw</code>，这一步主要将键值对封装成一个 <code>dictEntry</code> 并返回 ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 将 key 插入哈希表中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictAddRaw</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, dictEntry <span style="color:#f92672">**</span>existing)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> index;
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#f92672">*</span>entry;
</span></span><span style="display:flex;"><span>    dictht <span style="color:#f92672">*</span>ht;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果哈希表正在rehash，则向前 rehash一步(渐进式rehash的体现)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 是否正在进行 rehash，是通过 dict.rehashidx == -1 来判断的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dictIsRehashing</span>(d)) <span style="color:#a6e22e">_dictRehashStep</span>(d);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用_dictKeyIndex() 检查键是否存在，如果存在则返回NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((index <span style="color:#f92672">=</span> <span style="color:#a6e22e">_dictKeyIndex</span>(d, key, <span style="color:#a6e22e">dictHashKey</span>(d,key), existing)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取当前正在使用的ht，如果正在 rehash，使用 ht[1]，否则使用 ht[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ht <span style="color:#f92672">=</span> <span style="color:#a6e22e">dictIsRehashing</span>(d) <span style="color:#f92672">?</span> <span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">:</span> <span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新增的节点分配内存
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    entry <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>entry));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将结点插入链表头部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    entry<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> ht<span style="color:#f92672">-&gt;</span>table[index];
</span></span><span style="display:flex;"><span>    ht<span style="color:#f92672">-&gt;</span>table[index] <span style="color:#f92672">=</span> entry;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新结点数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ht<span style="color:#f92672">-&gt;</span>used<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置新节点的键，使用的是 type 属性中的 keyDup 函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">dictSetKey</span>(d, entry, key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> entry;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们再看 <code>_dictKeyIndex</code> 这个方法，作用是计算某个 <code>key</code> 应该存储在哪个空的 <code>bucket</code> ，即需要返回这个 <code>key</code> 应该存储在 <code>dictEntry</code> 数组的 <code>index</code>，如果已经存在，返回 -1。需要注意的是，当哈希表正在 <code>rehash</code> 时，返回的 <code>index</code> 应该是要搬迁的 <code>ht</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 传进来的 existing 是 NULL, hash是通过 type 中的哈希函数计算的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">_dictKeyIndex</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">uint64_t</span> hash, dictEntry <span style="color:#f92672">**</span>existing)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> idx, table;
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#f92672">*</span>he;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (existing)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>existing <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查是否需要扩展哈希表，如果需要则进行扩展
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">_dictExpandIfNeeded</span>(d) <span style="color:#f92672">==</span> DICT_ERR)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; table <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; table<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        idx <span style="color:#f92672">=</span> hash <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[table].sizemask;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Search if this slot does not already contain the given key */</span>
</span></span><span style="display:flex;"><span>        he <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[table].table[idx];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (he)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> he<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">||</span> <span style="color:#a6e22e">dictCompareKeys</span>(d, key, he<span style="color:#f92672">-&gt;</span>key))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (existing)
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">*</span>existing <span style="color:#f92672">=</span> he;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            he <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">dictIsRehashing</span>(d))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> idx;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后，我们关注 <strong>检查是否需要 <code>rehash</code>，需要则启动</strong> 的 <code>_dictExpandIfNeeded</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_dictExpandIfNeeded</span>(dict <span style="color:#f92672">*</span>d)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果正在 rehash，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dictIsRehashing</span>(d))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> DICT_OK;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* If the hash table is empty expand it to the initial size. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果哈希表中是空的，则将其收缩为初始化大小 DICT_HT_INITIAL_SIZE=4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].size <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dictExpand</span>(d, DICT_HT_INITIAL_SIZE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在 (ht[0].used/ht[0].size)&gt;=1前提下，如果 系统允许扩容 或者 ht[0].used/t[0].size&gt;5 时，容量扩展为原来的2倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">&gt;=</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].size <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>        (dict_can_resize <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>         d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">/</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].size <span style="color:#f92672">&gt;</span> dict_force_resize_ratio))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">dictExpand</span>(d, d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>);  <span style="color:#75715e">// 扩容至原来容量的2倍
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> DICT_OK;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>仔细看看 <code>dictExpand</code> 是如何扩展哈希表容量的，这个函数中，判断是否需要扩容，如果需要，则新申请一个 <code>dictht</code> ，赋值给 <code>ht[0]</code>，然后将字典的状态设置为 <strong>正在 <code>rehash</code>(rehashidx &gt; -1)</strong>，需要注意的是，这个方法中并没有实际进行键值对的搬迁：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 扩容 或者 新建一个 dictht
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictExpand</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* the size is invalid if it is smaller than the number of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * elements already inside the hash table */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果正在 reahsh 或者 传进来的size不合适(size比当前已有的容量小，正常情况下这是不可能的)，直接返回错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dictIsRehashing</span>(d) <span style="color:#f92672">||</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">&gt;</span> size)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> DICT_ERR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dictht n; <span style="color:#75715e">// 新哈希表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 计算 扩展或缩放新哈希表容量 的大小，必须是2的倍数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> realsize <span style="color:#f92672">=</span> <span style="color:#a6e22e">_dictNextPower</span>(size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果计算扩容后的新哈希表的容量，和原来的相同，就没必要扩容，直接返回错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (realsize <span style="color:#f92672">==</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].size)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> DICT_ERR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为新哈希表申请内存，并将所有的指针初始化为NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    n.size <span style="color:#f92672">=</span> realsize;
</span></span><span style="display:flex;"><span>    n.sizemask <span style="color:#f92672">=</span> realsize <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    n.table <span style="color:#f92672">=</span> <span style="color:#a6e22e">zcalloc</span>(realsize <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(dictEntry <span style="color:#f92672">*</span>));
</span></span><span style="display:flex;"><span>    n.used <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Is this the first initialization? If so it&#39;s not really a rehashing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * we just set the first hash table so that it can accept keys. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果原来的哈希表是空的，意味着这是在新建一个哈希表，将新申请的 dictht 赋值给 ht[0]，直接返回创建成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> DICT_OK;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果不是新建哈希表，那就是需要实打实的扩容，此时将刚才新申请的 哈希表 赋值给 ht[1]，并将当前字典状态设置为&#34;正在rehash&#34;(rehashidx &gt; -1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> n;
</span></span><span style="display:flex;"><span>    d<span style="color:#f92672">-&gt;</span>rehashidx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> DICT_OK;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 哈希表的容量必须是 2的倍数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">_dictNextPower</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> i <span style="color:#f92672">=</span> DICT_HT_INITIAL_SIZE;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (size <span style="color:#f92672">&gt;=</span> LONG_MAX)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> LONG_MAX <span style="color:#f92672">+</span> <span style="color:#ae81ff">1LU</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> size)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>什么时候进行 <strong>桶</strong> 的搬迁呢？这里涉及到一个名词：<strong>渐进式扩容</strong>。我们知道，扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 <code>rehash</code> 到 <code>ht[1]</code> 里面，如果哈希表中的键值对数量少，那么一次性转移过去不是问题；但是键值对的数量很大，几百万几千万甚至上亿，那么一次性搬完的计算量+单线程很有可能使 <code>redis</code> 服务停止一段时间。因此，为了避免 <code>rehash</code> 对服务造成影响，服务不是一次性 <code>rehash</code> 完成的，而是 <strong>分多次</strong>、<strong>渐进式</strong>地将 <code>ht[0]</code> 中的键值对搬迁到 <code>ht[1]</code> 中。</p>
<p>源码中真正执行搬迁的函数是 <code>_dictRehashStep</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// _dictRehashStep 让 rehash 的动作向前走一步(搬迁一个桶)，前提是当前字典没有被遍历，即iterators==0，iterators表示当前正在遍历此字典的迭代器数目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_dictRehashStep</span>(dict <span style="color:#f92672">*</span>d)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>iterators <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">dictRehash</span>(d, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>再看 <code>dictRehash</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// dictRehash 向前 rehash n步。如果还没有搬迁完，返回 1，搬迁完成返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictRehash</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当dictRehash时，rehashidx指向当前正在被搬迁的bucket，如果这个bucket中一个可搬迁的dictEntry都没有，说明就没有可搬迁的数据。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 这个时候会继续向后遍历 ht[0].table 数组，直到找到下一个存有数据的bucket位置，如果一直找不到，则最多向前走 empty_visits 步，本次搬迁任务结束。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> empty_visits <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 整个dict的 rehash 完成了，返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">dictIsRehashing</span>(d))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 外层大循环，确保本次最多向前走n步 以及 ht[0].table中还有值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (n<span style="color:#f92672">--</span> <span style="color:#f92672">&amp;&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        dictEntry <span style="color:#f92672">*</span>de, <span style="color:#f92672">*</span>nextde;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 确保 rehashidx 不会超过 ht[0].table 的长度，因为 rehashidx 指向当前正在被搬迁的bucket，其实就是 ht[0].table 数组的下标，这里保证数组下标访问不会越界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">assert</span>(d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].size <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>)d<span style="color:#f92672">-&gt;</span>rehashidx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 当前的bucket搬迁完了，继续寻找下一个bucket，知道全部为空 或者 向前走的步数超过了限定值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table[d<span style="color:#f92672">-&gt;</span>rehashidx] <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            d<span style="color:#f92672">-&gt;</span>rehashidx<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>empty_visits <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 终于找到了可搬迁的某个bucket中的 dictEntry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        de <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table[d<span style="color:#f92672">-&gt;</span>rehashidx];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将这个 bucket 中的所有 dictEntry 包括链表上的，前部搬迁到新的 ht[1] 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (de)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">uint64_t</span> h;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            nextde <span style="color:#f92672">=</span> de<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取当前键值对在新的哈希表中的桶的序号，这里进行取模的是 ht[1]的sizemask，所以 h 很大概率会与在 ht[0] 中的不一样
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            h <span style="color:#f92672">=</span> <span style="color:#a6e22e">dictHashKey</span>(d, de<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].sizemask;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新 新桶与旧桶 中的属性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            de<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].table[h];
</span></span><span style="display:flex;"><span>            d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].table[h] <span style="color:#f92672">=</span> de;
</span></span><span style="display:flex;"><span>            d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            de <span style="color:#f92672">=</span> nextde;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 搬迁完成，将原来的ht[0]中的bucket置空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table[d<span style="color:#f92672">-&gt;</span>rehashidx] <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// rehashidx 自增，表示又搬完了一个桶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        d<span style="color:#f92672">-&gt;</span>rehashidx<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查是否搬完了整张表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 全部完成搬迁，则释放掉ht[0]的内存，将ht[1]的内容放到ht[0]中，重置ht[1]，并标志rehash完成(rehashidx=-1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">zfree</span>(d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table);
</span></span><span style="display:flex;"><span>        d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_dictReset</span>(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        d<span style="color:#f92672">-&gt;</span>rehashidx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 否则后面的动作还要继续搬迁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>那什么时候会进行渐进式<code>rehash</code>呢？在源码中搜索 <code>_dictRehashStep</code>：有以下几处出现了：</p>
<ol>
<li><code>dictAddRaw</code> ：向字典增加一个键值对时；</li>
<li><code>dictGenericDelete</code>：查找并移除某个键值对时；</li>
<li><code>dictFind</code> ：根据 <code>key</code> 查找对应的 <code>dictEntry</code> 时；</li>
<li><code>dictGetRandomKey</code>：返回一个随机的 <code>dictEntry</code> 时；</li>
<li><code>dictGetSomeKeys</code>：随机返回指定 <code>count</code> 个 <code>dictEntry</code> 时，会进行 <code>count</code> 次 <code>_dictRehashStep</code></li>
</ol>
<p>总结一下：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 <code>rehash</code> 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 <code>rehash</code> 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 <code>rehash</code> 操作已完成。</li>
</ol>
<p><strong>渐进式 <code>rehash</code> 的好处在于它采取分而治之的方式， 将 <code>rehash</code> 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 <code>rehash</code> 而带来的庞大计算量</strong>。</p>
<h4 id="35-api">3.5 API<a hidden class="anchor" aria-hidden="true" href="#35-api">#</a></h4>
<ul>
<li><strong>添加键值对 <code>dictAdd</code></strong></li>
</ul>
<p>在上面讲 <code>rehash</code> 时，使用的例子，就是 添加键值对，这里不再赘述。</p>
<ul>
<li><strong>删除键值对 <code>dictDelete</code></strong></li>
</ul>
<p>其底层调用的是 <code>dictGenericDelete</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 找到key对应的键值对，并移除它。此处dictDelete 调用时传入 nofree=0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictGenericDelete</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">int</span> nofree)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint64_t</span> h, idx;
</span></span><span style="display:flex;"><span>    dictEntry <span style="color:#f92672">*</span>he, <span style="color:#f92672">*</span>prevHe;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> table;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果字典中键值对数量为0，返回 未找到
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果当前处于 rehash 阶段，则往前进行一步 rehash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">dictIsRehashing</span>(d))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_dictRehashStep</span>(d);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    h <span style="color:#f92672">=</span> <span style="color:#a6e22e">dictHashKey</span>(d, key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; table <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; table<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取桶的索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        idx <span style="color:#f92672">=</span> h <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[table].sizemask;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取桶中的第一个 dictEntry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        he <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[table].table[idx];
</span></span><span style="display:flex;"><span>        prevHe <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 遍历链表，找到之后将其从链表中删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (he)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">==</span> he<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">||</span> <span style="color:#a6e22e">dictCompareKeys</span>(d, key, he<span style="color:#f92672">-&gt;</span>key))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (prevHe)
</span></span><span style="display:flex;"><span>                    prevHe<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>                    d<span style="color:#f92672">-&gt;</span>ht[table].table[idx] <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nofree)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">dictFreeKey</span>(d, he);
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">dictFreeVal</span>(d, he);
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">zfree</span>(he);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                d<span style="color:#f92672">-&gt;</span>ht[table].used<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> he;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            prevHe <span style="color:#f92672">=</span> he;
</span></span><span style="display:flex;"><span>            he <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果没有再 rehash，就没必要再去 ht[1] 中寻找了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">dictIsRehashing</span>(d))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> NULL; <span style="color:#75715e">// 没找到，返回 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ul>
<li><strong>查找键值对 <code>dictFind</code></strong></li>
</ul>
<p>过程跟 <code>dictGenericDelete</code> 一模一样， <code>dictGenericDelete</code> 还多了一个删除操作。</p>
<h3 id="4-跳表">4. 跳表<a hidden class="anchor" aria-hidden="true" href="#4-跳表">#</a></h3>
<p>会有专门的一篇文章来讲。看这里：<a href="https://jemmyh.github.io/2020/10/05/tiao-biao/">跳表原理以及 Golang 实现</a></p>
<h3 id="5-整数集合">5. 整数集合<a hidden class="anchor" aria-hidden="true" href="#5-整数集合">#</a></h3>
<p>当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。当然，当整数集合中的 <strong>元素太多(redis.conf 中 <code>set-max-intset-entries=512</code>)</strong> 或者 <strong>添加别的类型的元素</strong>是，整个整数集合会被转化成 <strong>字典</strong>。</p>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/intset.h">intset.h</a></p></blockquote>
<h4 id="51-数据结构">5.1 数据结构<a hidden class="anchor" aria-hidden="true" href="#51-数据结构">#</a></h4>
<p><strong>整数集合（<code>intset</code>）</strong> 是 <code>Redis</code> 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现重复元素。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> intset {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> encoding;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 集合中包含的元素数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 保存元素的数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int8_t</span> contents[];
</span></span><span style="display:flex;"><span>} intset;
</span></span></code></pre></div><p><code>contents</code> 数组中的元素按照从小到大的顺序排列，并且保证没有重复值；<code>length</code> 表示整数集合中包含的元素数量，即 <code>contents</code> 数组的长度。虽然 <code>contents</code> 数组的类型是 <code>int8_t</code>，但实际上并不保存 <code>int8_t</code> 类型的值，而是会根据实际 <code>encoding</code> 的值做出判断，比如 <code>encoding = INTSET_ENC_INT16</code>，那么数组的底层类型均为 <code>int16_t</code> ，整个数组中的元素类型都是 <code>int16_t</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* Note that these encodings are ordered, so:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * INTSET_ENC_INT16 &lt; INTSET_ENC_INT32 &lt; INTSET_ENC_INT64. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define INTSET_ENC_INT16 (sizeof(int16_t))  </span><span style="color:#75715e">// int16 16位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define INTSET_ENC_INT32 (sizeof(int32_t))  </span><span style="color:#75715e">// int32 32位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define INTSET_ENC_INT64 (sizeof(int64_t))  </span><span style="color:#75715e">// int64 64位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回 v 对应的 encoding 值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">uint8_t</span> <span style="color:#a6e22e">_intsetValueEncoding</span>(<span style="color:#66d9ef">int64_t</span> v) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">&lt;</span> INT32_MIN <span style="color:#f92672">||</span> v <span style="color:#f92672">&gt;</span> INT32_MAX)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> INTSET_ENC_INT64;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (v <span style="color:#f92672">&lt;</span> INT16_MIN <span style="color:#f92672">||</span> v <span style="color:#f92672">&gt;</span> INT16_MAX)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> INTSET_ENC_INT32;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> INTSET_ENC_INT16;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面是一个使用 <code>INTSET_ENC_INT16</code> 编码的、长度为 6 的整数集合：</p>
<p><img alt="整数集合举例" loading="lazy" src="https://pic.downk.cc/item/5f788aa8160a154a6719f5d2.png"></p>
<h4 id="52-api">5.2 API<a hidden class="anchor" aria-hidden="true" href="#52-api">#</a></h4>
<ul>
<li><strong>初始化 <code>intset</code></strong></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个空的 intset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>intset <span style="color:#f92672">*</span><span style="color:#a6e22e">intsetNew</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为 intset 对象申请空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    intset <span style="color:#f92672">*</span>is <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(<span style="color:#66d9ef">sizeof</span>(intset));
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 默认使用 INTSET_ENC_INT16 作为存储大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    is<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(INTSET_ENC_INT16);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 数组长度为0，因为没有初始化的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    is<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> is;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里有一点需要注意，创建 <code>intset</code> 的时候并没有初始化 <code>contents</code> 数组，应为没必要。在常规情况下，访问数组是根据数组第一个元素地址加上类型大小作为偏移值读取，但是 <code>intset</code> 的数据类型依赖于 <code>encoding</code>，读取的时候通过 <code>memcpy</code> 按照 <code>encoding</code> 的值重新计算偏移量暴力读取的，属于 非常规操作数据，因此，刚开始没必要申请数组的空间，等添加一个元素时，动态扩容该元素的大小的内存即可。</p>
<ul>
<li><strong>添加元素</strong></li>
</ul>
<p>我们先看代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 在 intset 中添加一个整数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>intset <span style="color:#f92672">*</span><span style="color:#a6e22e">intsetAdd</span>(intset <span style="color:#f92672">*</span>is, <span style="color:#66d9ef">int64_t</span> value, <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>success) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> valenc <span style="color:#f92672">=</span> <span style="color:#a6e22e">_intsetValueEncoding</span>(value);  <span style="color:#75715e">// 根据要插入的 value 的类型 获取对应的 encoding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> pos;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (success) <span style="color:#f92672">*</span>success <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// success = NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (valenc <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>encoding)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入元素的 encoding 值大于 intset 当前的，升级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">intsetUpgradeAndAdd</span>(is,value);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 插入元素的 encoding 值小于等于当前 intset 的，则找到这个 value 应该插入的位置，赋值给 pos，已经存在的话直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">intsetSearch</span>(is,value,<span style="color:#f92672">&amp;</span>pos)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (success) <span style="color:#f92672">*</span>success <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> is;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 动态扩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        is <span style="color:#f92672">=</span> <span style="color:#a6e22e">intsetResize</span>(is,<span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将 pos 位置后面的元素整体向后挪一位，给 pos 腾位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pos <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length)) <span style="color:#a6e22e">intsetMoveTail</span>(is,pos,pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 pos 位置设置为 value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">_intsetSet</span>(is,pos,value);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新 length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    is<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> is;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 动态扩容，即将原来数组的容量 (is.length*encoding) 调整为 ((is.length+1)*encoding)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> intset <span style="color:#f92672">*</span><span style="color:#a6e22e">intsetResize</span>(intset <span style="color:#f92672">*</span>is, <span style="color:#66d9ef">uint32_t</span> len) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> size <span style="color:#f92672">=</span> len<span style="color:#f92672">*</span><span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>encoding);
</span></span><span style="display:flex;"><span>    is <span style="color:#f92672">=</span> <span style="color:#a6e22e">zrealloc</span>(is,<span style="color:#66d9ef">sizeof</span>(intset)<span style="color:#f92672">+</span>size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> is;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 暴力迁移pos位置之后的数据，为pos位置挪出位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">intsetMoveTail</span>(intset <span style="color:#f92672">*</span>is, <span style="color:#66d9ef">uint32_t</span> from, <span style="color:#66d9ef">uint32_t</span> to) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// from = pos, to = pos+1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// src 表示 pos 相对于数组头部的迁移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// dst 表示 pos下一个元素相对于数组头部的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>src, <span style="color:#f92672">*</span>dst;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// pos位置 距离数组末尾的元素个数，bytes*类型大小 即是pos后面的所有元素的总长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> bytes <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length)<span style="color:#f92672">-</span>from;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// encoding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint32_t</span> encoding <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>encoding);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (encoding <span style="color:#f92672">==</span> INTSET_ENC_INT64) {
</span></span><span style="display:flex;"><span>        src <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int64_t</span><span style="color:#f92672">*</span>)is<span style="color:#f92672">-&gt;</span>contents<span style="color:#f92672">+</span>from;
</span></span><span style="display:flex;"><span>        dst <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int64_t</span><span style="color:#f92672">*</span>)is<span style="color:#f92672">-&gt;</span>contents<span style="color:#f92672">+</span>to;
</span></span><span style="display:flex;"><span>        bytes <span style="color:#f92672">*=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int64_t</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (encoding <span style="color:#f92672">==</span> INTSET_ENC_INT32) {
</span></span><span style="display:flex;"><span>        src <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int32_t</span><span style="color:#f92672">*</span>)is<span style="color:#f92672">-&gt;</span>contents<span style="color:#f92672">+</span>from;
</span></span><span style="display:flex;"><span>        dst <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int32_t</span><span style="color:#f92672">*</span>)is<span style="color:#f92672">-&gt;</span>contents<span style="color:#f92672">+</span>to;
</span></span><span style="display:flex;"><span>        bytes <span style="color:#f92672">*=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int32_t</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        src <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int16_t</span><span style="color:#f92672">*</span>)is<span style="color:#f92672">-&gt;</span>contents<span style="color:#f92672">+</span>from;
</span></span><span style="display:flex;"><span>        dst <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int16_t</span><span style="color:#f92672">*</span>)is<span style="color:#f92672">-&gt;</span>contents<span style="color:#f92672">+</span>to;
</span></span><span style="display:flex;"><span>        bytes <span style="color:#f92672">*=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int16_t</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从 src 复制 bytes 个字符到 dst
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">memmove</span>(dst,src,bytes);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>整个过程可以简单总结为：先判断当前插入值的 <code>encoding</code> 是否超过了 <code>intset</code> 的，如果超过了，进行升级，<strong>升级</strong> 操作我们待会儿再看。没超过的话，需要找到当前元素应该插入的位置 <code>pos</code> ，<strong>查找</strong> 操作我们还是待会儿再看。之后是动态扩容，动态扩容的过程有：先将数组容量增加，之后将 <code>pos</code> 后面的元素整体移一位，最后将 <code>value</code> 值写入 <code>pos</code> 处。特别需要注意的是，<strong>将 <code>pos</code> 后面的元素整体后移一位</strong> 这一步，没有逐个移动元素，而是计算好 <code>src</code> 和 <code>dst</code>，直接调用 <code>memmove</code> 将 <code>src</code> 处的 <code>bytes</code> 个字符复制到 <code>dst</code> 处，这正是利用了 <code>intset</code> 数组非常规读取数组的特点。下面通过一个例子看一下插入的过程：</p>
<p><img alt="intset插入元素" loading="lazy" src="https://pic.downk.cc/item/5f789ebf160a154a671f936b.png"></p>
<ul>
<li><strong>升级</strong></li>
</ul>
<p>当插入的元素的类型比集合中现有所有元素的类型都要长时，需要先将数组整个升级之后，才能继续插入元素。<strong>升级</strong> 指的是 将数组类型变成和插入值类型相同的过程。</p>
<p>升级过程大致可分为三个步骤：</p>
<ol>
<li>根据新元素类型，扩展底层数组的大小，并为新元素分配空间；</li>
<li>将底层数组的所有元素都转化成与新元素相同，并将转换后的元素放在合适的位置上，并且在防止的过程中，需要维持底层数组中数组顺序不变；</li>
<li>将新元素添加到新数组中</li>
</ol>
<p>下面我们直接看代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> intset <span style="color:#f92672">*</span><span style="color:#a6e22e">intsetUpgradeAndAdd</span>(intset <span style="color:#f92672">*</span>is, <span style="color:#66d9ef">int64_t</span> value) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint8_t</span> curenc <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>encoding);  <span style="color:#75715e">// 当前 encoding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">uint8_t</span> newenc <span style="color:#f92672">=</span> <span style="color:#a6e22e">_intsetValueEncoding</span>(value); <span style="color:#75715e">// 插入元素的 encoding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 插入到 数组最左边 还是 数组最右边。为什么会是最值？因为要升级，所以插入值肯定超出了现有 encoding 对应类型的最值，要么是负数越界，要么是正数越界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> prepend <span style="color:#f92672">=</span> value <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">?</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 首先，设置 intset 的 encoding 为插入元素的 encoding(更大的那个)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    is<span style="color:#f92672">-&gt;</span>encoding <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(newenc);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 根据新元素类型 扩展数组大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    is <span style="color:#f92672">=</span> <span style="color:#a6e22e">intsetResize</span>(is,<span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从数组最后一个元素开始遍历，将其放入合适的位置。prepend 的作用就是确保我们能给待插入值留下最左边的位置 或 最右边的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(length<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_intsetSet</span>(is,length<span style="color:#f92672">+</span>prepend,<span style="color:#a6e22e">_intsetGetEncoded</span>(is,length,curenc));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在数组头部或者数组尾部插入 value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (prepend)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_intsetSet</span>(is,<span style="color:#ae81ff">0</span>,value);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">_intsetSet</span>(is,<span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length),value);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 最后更新 length
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    is<span style="color:#f92672">-&gt;</span>length <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> is;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>通过一个例子说明升级的过程：</p>
<p><img alt="整数集合升级" loading="lazy" src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjcm49s2sfj30nn0tmk4v.jpg"></p>
<p>注意：整数集合没有降级操作！一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<ul>
<li><strong>查找</strong></li>
</ul>
<p>在 <code>intset</code> 中查找 <code>value</code> 是否存在，如果存在，返回 1，同时将 <code>pos</code> 值设置为数组的索引值；如果不存在，返回 0，同时将 <code>pos</code> 设置成应该存放的位置的索引值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">uint8_t</span> <span style="color:#a6e22e">intsetSearch</span>(intset <span style="color:#f92672">*</span>is, <span style="color:#66d9ef">int64_t</span> value, <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>pos) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, max <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, mid <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int64_t</span> cur <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当 intset 中没有元素时，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pos) <span style="color:#f92672">*</span>pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 大于当前数组中最大值 或 小于最小值，也是直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">_intsetGet</span>(is,max)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pos) <span style="color:#f92672">*</span>pos <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(is<span style="color:#f92672">-&gt;</span>length);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">_intsetGet</span>(is,<span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (pos) <span style="color:#f92672">*</span>pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 因为数组有序，所以采用二分法查找位置是一个非常正确的选择
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(max <span style="color:#f92672">&gt;=</span> min) {
</span></span><span style="display:flex;"><span>        mid <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>)min <span style="color:#f92672">+</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>)max) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        cur <span style="color:#f92672">=</span> <span style="color:#a6e22e">_intsetGet</span>(is,mid);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&gt;</span> cur) {
</span></span><span style="display:flex;"><span>            min <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">&lt;</span> cur) {
</span></span><span style="display:flex;"><span>            max <span style="color:#f92672">=</span> mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (value <span style="color:#f92672">==</span> cur) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// value 已经存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pos) <span style="color:#f92672">*</span>pos <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// value 不存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pos) <span style="color:#f92672">*</span>pos <span style="color:#f92672">=</span> min;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="53-总结">5.3 总结<a hidden class="anchor" aria-hidden="true" href="#53-总结">#</a></h4>
<ul>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
<li>整数集合中的元素不能太对，当超过配置值后，会被转化成字典。</li>
</ul>
<h3 id="6-压缩列表">6. 压缩列表<a hidden class="anchor" aria-hidden="true" href="#6-压缩列表">#</a></h3>
<p><strong>压缩列表</strong> 是 <code>Redis</code> 自己实现的一个数据存储结构，有点类似数组，通过一片连续的空间存储数据，只不过数组的每个元素大小都相同，压缩列表允许每个元素有自己的大小。其核心思想，就是在一个连续的内存上，模拟出一个链表的结构。</p>
<p>在源代码中有这么一段描述：</p>
<blockquote>
<p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.</p></blockquote>
<p>大致意思是：<code>ziplist</code> 是一个<strong>经过特殊编码的双向链表</strong>，它的设计目标就是为了<strong>提高存储效率</strong>。<code>ziplist</code> 可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以 <code>O(1)</code> 的时间复杂度在表的两端提供 <code>push</code> 和 <code>pop</code> 操作。但由于每次操作都需要重新分配 <code>ziplist</code> 使用的内存，所以实际的复杂度与 <code>ziplist</code> 使用的内存量有关。</p>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/ziplist.h">ziplist.h</a></p></blockquote>
<h4 id="61-数据结构">6.1 数据结构<a hidden class="anchor" aria-hidden="true" href="#61-数据结构">#</a></h4>
<p><code>ziplist</code> 并没有实际的 <code>struct</code> 表示，但在 <code>ziplist.c</code> 中有如下描述：</p>
<blockquote>
<p>The general layout of the ziplist is as follows:</p>
<p><strong>&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; &hellip; &lt;entry&gt; &lt;zlend&gt;</strong></p>
<ul>
<li><code>zlbytes</code>：本身占用 4 字节，整个压缩列表占用的总字节数(包括他自己)</li>
<li><code>zltail</code>：本身占用 4 字节，起始位置到最后一个结点的偏移量，用来快速定位最后一个元素，在反向输出压缩列表时会有用</li>
<li><code>zllen</code>：本身占用 2 字节，压缩列表包含的元素个数</li>
<li><code>entry</code>：元素内容。用数组存储，内存上紧挨着</li>
<li><code>zlend</code>：本身占用 1 字节，压缩列表结束的标志位，一般为常量 <code>0xFF</code></li>
</ul></blockquote>
<p>接下来看 <code>entry</code> 这个结构：</p>
<blockquote>
<p><strong>&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</strong></p>
<ul>
<li><code>prevlen</code>：1 字节或者 5 字节，表示前一个 <code>entry</code> 长度，在反向遍历的时候会有用</li>
<li><code>encoding</code>：1、2 或 5 字节，表示当前 <code>entry</code> 的编码方式，表示当前 <code>entry</code> 的类型，<code>integer</code> 或 <code>string</code></li>
<li><code>entry-data</code>：实际所需的字节数，结点真正的值，可以是 <code>integer</code> 或 <code>string</code>。它的类型和长度由 <code>encoding</code> 来决定</li>
</ul></blockquote>
<p>接下来我们详细关注这三个参数：</p>
<h5 id="prevlen"><code>prevlen</code><a hidden class="anchor" aria-hidden="true" href="#prevlen">#</a></h5>
<p>以字节为单位，记录前一个 <code>entry</code> 的长度。<code>prevlen</code> 的长度可以是 <strong>1 字节</strong> 或者 <strong>5 字节</strong>：</p>
<ul>
<li>当前一个结点的长度小于 254 字节时，<code>prevlen</code> 的长度为 <strong>1 字节</strong>，前一个 <code>entry</code> 的长度就保存在这一个字节中；</li>
<li>当前一个结点的长度大于等于 254 字节时，<code>prevlen</code> 的长度为 <strong>5 字节</strong>，其中第一个字节会被设置成 <code>0xFE</code>(十进制的 <code>254</code>)，表示这是一个 <strong>5 字节长</strong> 的 <code>prevlen</code>，后面的四个字节则保存前一个 <code>entry</code> 的长度。</li>
</ul>
<p><code>prevlen</code> 的作用是：在反向遍历压缩数组时，可以通过当前元素的指针，减去 <code>prevlen</code> ，就能得到前一个元素的地址。</p>
<p><img loading="lazy" src="https://pic.downk.cc/item/5f78e315160a154a672db33d.png"></p>
<h5 id="encoding"><code>encoding</code><a hidden class="anchor" aria-hidden="true" href="#encoding">#</a></h5>
<p>节点的 <code>encoding</code> 属性记录了节点的 <code>entry-data</code> 属性所保存 <strong>数据的类型</strong> 以及 <strong>长度</strong>：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 <code>00</code> 、 <code>01</code> 或者 <code>10</code> 的是<strong>字节数组编码</strong>： 这种编码表示节点的 <code>content</code> 属性保存着 <strong>字符串(字节数组)</strong>， 数组的长度由编码除去最高两位之后的其他位记录：</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: left">编码</th>
          <th style="text-align: center">编码长度</th>
          <th style="text-align: center">content 中保存的值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">00bbbbbb</td>
          <td style="text-align: center"><strong>1 字节</strong></td>
          <td style="text-align: center">长度小于等于 63 字节的字节数组(6 位分辨位，2^6 = 64，除去全 0 的)</td>
      </tr>
      <tr>
          <td style="text-align: left">01bbbbbb | xxxxxxxx</td>
          <td style="text-align: center"><strong>2 字节</strong></td>
          <td style="text-align: center">长度小于等于 16383 字节的字节数组(14 位分辨位，2^14 = 16384，除去全 0 的)</td>
      </tr>
      <tr>
          <td style="text-align: left">10000000 | xxxx…xxxx(32 位)</td>
          <td style="text-align: center"><strong>5 字节</strong></td>
          <td style="text-align: center">长度小于等于 4294967295 字节的字节数组(32 位分辨位，2^32 = 4294967296)</td>
      </tr>
  </tbody>
</table>
<ul>
<li>一字节长， 值的最高位以 <code>11</code> 开头的是<strong>整数编码</strong>： 这种编码表示节点的 <code>entry-data</code> 属性保存着<strong>整数</strong>值， 整数值的类型和长度由编码除去最高两位之后的其他位记录:</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: left">编码</th>
          <th style="text-align: center">编码长度</th>
          <th style="text-align: center">entry-data 中保存的值</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">11000000</td>
          <td style="text-align: center">1 字节</td>
          <td style="text-align: center">int16_t 类型整数</td>
      </tr>
      <tr>
          <td style="text-align: left">11010000</td>
          <td style="text-align: center">1 字节</td>
          <td style="text-align: center">int32_t 类型整数</td>
      </tr>
      <tr>
          <td style="text-align: left">11100000</td>
          <td style="text-align: center">1 字节</td>
          <td style="text-align: center">int64_t 类型整数</td>
      </tr>
      <tr>
          <td style="text-align: left">11110000</td>
          <td style="text-align: center">1 字节</td>
          <td style="text-align: center">24 位有符号整数</td>
      </tr>
      <tr>
          <td style="text-align: left">11111110</td>
          <td style="text-align: center">1 字节</td>
          <td style="text-align: center">8 位有符号整数</td>
      </tr>
      <tr>
          <td style="text-align: left">1111xxxx</td>
          <td style="text-align: center">1 字节</td>
          <td style="text-align: center">使用这一编码的节点没有相应的 <code>entry-data</code> 属性， 因为编码本身的 <code>xxxx</code> 四个位已经保存了一个介于 <code>0</code> 和 <code>12</code> 之间的值， 所以它无须 <code>entry-data</code> 属性。</td>
      </tr>
  </tbody>
</table>
<h5 id="entry-data"><code>entry-data</code><a hidden class="anchor" aria-hidden="true" href="#entry-data">#</a></h5>
<p>节点的 <code>entry-data</code> 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 <code>encoding</code> 属性决定。</p>
<p><img loading="lazy" src="https://pic.downk.cc/item/5f78e80c160a154a672e5400.png"></p>
<p><img alt="压缩列表-示例" loading="lazy" src="https://pic.downk.cc/item/5f796b73160a154a674807ff.png"></p>
<h4 id="62-api">6.2 API<a hidden class="anchor" aria-hidden="true" href="#62-api">#</a></h4>
<ul>
<li><strong>创建<code>ziplist</code></strong></li>
</ul>
<p>返回一个只包含 <code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;zlend&gt;</code> 的 <code>ziplist</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ziplistNew</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> bytes <span style="color:#f92672">=</span> ZIPLIST_HEADER_SIZE<span style="color:#f92672">+</span>ZIPLIST_END_SIZE;  <span style="color:#75715e">// 头部的 4+4+2 和 尾部的1 总共 11 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl <span style="color:#f92672">=</span> <span style="color:#a6e22e">zmalloc</span>(bytes);  <span style="color:#75715e">// 这里的ziplist类型是一个 char 数组，而不是某个具体的结构体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ZIPLIST_BYTES</span>(zl) <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(bytes);  <span style="color:#75715e">// 设置 zlbytes 为 初始分配的值，即 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl) <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(ZIPLIST_HEADER_SIZE);  <span style="color:#75715e">// 设置 zltail 为 header 结束的地方
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ZIPLIST_LENGTH</span>(zl) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 设置 zllen 为 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    zl[bytes<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> ZIP_END;  <span style="color:#75715e">// 最后一个字节存储常量 255 ，表示 ziplist 结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> zl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>插入<code>ziplistInsert</code></strong></li>
</ul>
<p>这个函数的作用是 <strong>在 <code>ziplist</code> 的任意数据项前面插入一个新的数据项</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ziplistInsert</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> slen) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">__ziplistInsert</span>(zl,p,s,slen);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在 p 处 插入 s，s 的长度为 slen；插入后s占据p的位置，p及其后面的数据整体后移。其中 p 指向 ziplist 中某一个 entry 的起始位置，或者 zlend(当向尾部插入时)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">__ziplistInsert</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> slen) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// reqlen 表示 将 s 变成一个 entry 所需要的总字节数，即 prevlen,encoding,entry-data 的总长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">size_t</span> curlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">ZIPLIST_BYTES</span>(zl)), reqlen;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> prevlensize, prevlen <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> offset;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> nextdiff <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> encoding <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> value <span style="color:#f92672">=</span> <span style="color:#ae81ff">123456789</span>; <span style="color:#75715e">// 随便使用一个一眼就能看出来的值表示当前变量未被逻辑初始化，避免 warning
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    zlentry tail;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> ZIP_END) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果不是插入尾部，则根据p获取 p所在的 entry 的前一个 entry 的 prevlen，需要保存 prevlen的字节数保存在 prevlensize(1字节或者5字节，前面有介绍)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">ZIP_DECODE_PREVLEN</span>(p, prevlensize, prevlen);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// p 指向的是 尾部标志
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ptail <span style="color:#f92672">=</span> <span style="color:#a6e22e">ZIPLIST_ENTRY_TAIL</span>(zl);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ptail[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> ZIP_END) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 获取 ziplist 最后一个 entry 的长度，保存在 prevlen 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            prevlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">zipRawEntryLength</span>(ptail);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 尝试能否转化成整数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">zipTryEncoding</span>(s,slen,<span style="color:#f92672">&amp;</span>value,<span style="color:#f92672">&amp;</span>encoding)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 可以转化成 int，则 reqlen 即为存储此 int 所需的字节数，即 entry-data 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        reqlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">zipIntSize</span>(encoding);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 无法转换成 int，那就是字节数组，reqlen 就是要存入的字符串的长度，即 entry-data 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        reqlen <span style="color:#f92672">=</span> slen;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// reqlen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    reqlen <span style="color:#f92672">+=</span> <span style="color:#a6e22e">zipStorePrevEntryLength</span>(NULL,prevlen);  <span style="color:#75715e">// 再加上 prevlen 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    reqlen <span style="color:#f92672">+=</span> <span style="color:#a6e22e">zipStoreEntryEncoding</span>(NULL,encoding,slen);  <span style="color:#75715e">// 再加上 encoding 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当不是向尾部插入时，我们必须确保下一个 entry 的 prevlen 等于当前 entry 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> forcelarge <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 【1】nextdiff 存储的是p的prevlen的变化值(新元素长度reqlen - p之前entry的prelen)，具体解释看代码后面【1】处的解释
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    nextdiff <span style="color:#f92672">=</span> (p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> ZIP_END) <span style="color:#f92672">?</span> <span style="color:#a6e22e">zipPrevLenByteDiff</span>(p,reqlen) <span style="color:#f92672">:</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (nextdiff <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">&amp;&amp;</span> reqlen <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>) {
</span></span><span style="display:flex;"><span>        nextdiff <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        forcelarge <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// 这种情况下意味着，本来可以用 1 字节的，却使用了 5 个字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Store offset because a realloc may change the address of zl. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 存储 p 相对于 ziplist 的偏移量，因为 resize 可能改变 ziplist 的起始地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    offset <span style="color:#f92672">=</span> p<span style="color:#f92672">-</span>zl;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 到这一步已经能确定 ziplist 需要的总的容量了，调用 resize 调整 ziplist 的大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    zl <span style="color:#f92672">=</span> <span style="color:#a6e22e">ziplistResize</span>(zl,curlen<span style="color:#f92672">+</span>reqlen<span style="color:#f92672">+</span>nextdiff);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重新定位 p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> zl<span style="color:#f92672">+</span>offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 p 以及其后面的数据移动为 s 挪地方，别忘了更新 zltail 的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> ZIP_END) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在p前面腾出reqlen字节给新entry使用（将p move到p+reqlen，考虑了prelen缩减或增加）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">memmove</span>(p<span style="color:#f92672">+</span>reqlen,p<span style="color:#f92672">-</span>nextdiff,curlen<span style="color:#f92672">-</span>offset<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>nextdiff);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新 s 的后一个 entry（p+reqlen即p的新地址）的prevlen；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (forcelarge)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 【2】强制使用 5 字节存储，避免连锁更新时的大量重新分配空间操作，不进行缩容
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">zipStorePrevEntryLengthLarge</span>(p<span style="color:#f92672">+</span>reqlen,reqlen);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 计算 reqlen 进而判断使用 1 字节 还是 5 字节
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">zipStorePrevEntryLength</span>(p<span style="color:#f92672">+</span>reqlen,reqlen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 更新 zltail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl))<span style="color:#f92672">+</span>reqlen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          <span style="color:#75715e">// 更新zltail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">zipEntry</span>(p<span style="color:#f92672">+</span>reqlen, <span style="color:#f92672">&amp;</span>tail);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (p[reqlen<span style="color:#f92672">+</span>tail.headersize<span style="color:#f92672">+</span>tail.len] <span style="color:#f92672">!=</span> ZIP_END) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl))<span style="color:#f92672">+</span>nextdiff);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果是在尾部插入，则直接修改 zltail 为 s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl) <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(p<span style="color:#f92672">-</span>zl);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果 nexydiff 不等于0，整个 s 后面的 ziplist 的 prevlen 都可能发生变化，这里尝试进行维护
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (nextdiff <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        offset <span style="color:#f92672">=</span> p<span style="color:#f92672">-</span>zl;
</span></span><span style="display:flex;"><span>        zl <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ziplistCascadeUpdate</span>(zl,p<span style="color:#f92672">+</span>reqlen);
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> zl<span style="color:#f92672">+</span>offset;  <span style="color:#75715e">// 改变的只是 p 后面的，前面的没变，因此 s 插入的位置没变
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 存入 s 这个 entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">+=</span> <span style="color:#a6e22e">zipStorePrevEntryLength</span>(p,prevlen);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">+=</span> <span style="color:#a6e22e">zipStoreEntryEncoding</span>(p,encoding,slen);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ZIP_IS_STR</span>(encoding)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memcpy</span>(p,s,slen);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zipSaveInteger</span>(p,value,encoding);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ziplist 的长度加 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ZIPLIST_INCR_LENGTH</span>(zl,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> zl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将 ziplist 的长度变成 len
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">ziplistResize</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len) {
</span></span><span style="display:flex;"><span>    zl <span style="color:#f92672">=</span> <span style="color:#a6e22e">zrealloc</span>(zl,len);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ZIPLIST_BYTES</span>(zl) <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(len);
</span></span><span style="display:flex;"><span>    zl[len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> ZIP_END;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> zl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解释【1】：这种情况发生在 <strong>插入的位置不是尾部</strong> 的情况，我们假设 <code>p</code> 的前一个元素为 <code>p0</code>，此时 <code>p</code> 的 <code>prevlen</code> 存储的是 <code>p0</code> 的长度。但是由于要将 <code>s</code> 插入到 <code>p</code> 之前，那么 <code>p</code> 的 <code>prevlen</code> 的值就应该变成 <code>s</code> 的长度，这样 <code>p</code> 本身的长度也就发生了变化，有可能变大也有可能变小。这个变化了多少的值就是 <code>nextdiff</code>，如果变大了，<code>nextdiff</code> 是正数，否则是负数。如果是负数，只有一种情况，那就是 <code>p0</code> 的长度大于 254，用 5 个字节存；而 <code>s</code> 的长度小于 254，用 1 个字节存就够了。</p>
<p>解释【2】：关于 <code>forcelarge</code>，这是一个已经被修改后的 <a href="https://github.com/redis/redis/commit/8327b813#diff-b109b27001207a835769c556a54ff1b3">bug</a>，大致意思是，这种操作发生在 <strong>连锁更新</strong>(90 行) 的时候，为了防止大量的重新分配空间的动作，如果一个 <code>entry</code> 的长度只需要 1 个字节就能够保存,但是连锁更新时如果原先已经为 <code>prevlen</code> 分配了 5 个字节,则不会进行缩容操作。关于为何，可以参考这篇文章：<a href="https://erpeng.github.io/2019/04/15/Redis%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2bug%E5%8F%8A%E5%85%B6%E5%90%8E%E7%BB%AD%E6%94%B9%E8%BF%9B/">Redis 的一个历史 bug 及其后续改进</a>，作者对这个 <code>bug</code> 进行了复现，以及提到了 <code>Redis</code> 对此作出的更新(提出了更优化的结构 <code>listpack</code>)。</p>
<p>我们接着说 <strong>连锁更新</strong>。回忆一个 <code>entry</code> 的结构，其中 <code>prevlen</code> 表示前一个 <code>entry</code> 的长度：如果前一个结点长度小于 254，则 <code>prevlen</code> 占用 1 字节，否则占用 5 字节。现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 <code>250</code> 字节到 <code>253</code> 字节之间的节点 <code>e1</code> 至 <code>eN</code> 。因为 <code>e1</code> 至 <code>eN</code> 的所有节点的长度都小于 <code>254</code> 字节， 所以记录这些节点的长度只需要 <code>1</code> 字节长的 <code>prevlen</code> 属性， 换句话说， <code>e1</code> 至 <code>eN</code> 的所有节点的 <code>prevlen</code> 属性都是 <code>1</code> 字节长的。此时，如果我们在 <code>e1</code> 前面插入一个长度大于 254 的元素 <code>m</code>，因为 <code>e1</code> 的 <code>prevlen</code> 仅为 1 字节，无法保存大于 254 的数，因此，我们还要对 <code>ziplist</code> 进行空间重分配操作，使得 <code>e1</code> 能够保存 <code>m</code> 的长度，即将 <code>ziplist</code> 的大小再增加 4 字节，让 <code>e1</code> 的 <code>prevlen</code> 大小由 1 字节变为 5 字节，这种操作我们称为 <code>m</code> 对 <code>e1</code> 发生了 <strong>扩展</strong>。回到刚才的情况，现在麻烦来了，<code>e1</code> 大小发生了变化，肯定超过了原来的 254，此时 <code>e1</code> 需要对 <code>e2</code> 进行扩展，又到后面，<code>e2</code> 需要对 <code>e3</code> 进行扩展……程序需要不断地对压缩列表执行空间重分配操作， 直到 <code>eN</code> 为止。</p>
<p><code>Redis</code> 将这种在特殊情况下产生的连续多次空间扩展操作称之为 <strong>“连锁更新”（<code>cascade update</code>）</strong>。我们看看 <strong>连锁更新</strong> 的具体实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// p 指向第一个不需要更新的 entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">__ziplistCascadeUpdate</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>zl, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> curlen <span style="color:#f92672">=</span> <span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">ZIPLIST_BYTES</span>(zl)), rawlen, rawlensize;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">size_t</span> offset, noffset, extra;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>np;
</span></span><span style="display:flex;"><span>    zlentry cur, next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当 p 是 ziplist 的”尾巴“时停止更新
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> ZIP_END) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zipEntry</span>(p, <span style="color:#f92672">&amp;</span>cur);  <span style="color:#75715e">// 【1】将 entry 解码称为一个易于操作的 entry 结构体，细节见代码后解释
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        rawlen <span style="color:#f92672">=</span> cur.headersize <span style="color:#f92672">+</span> cur.len; <span style="color:#75715e">// 当前节点的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        rawlensize <span style="color:#f92672">=</span> <span style="color:#a6e22e">zipStorePrevEntryLength</span>(NULL,rawlen);  <span style="color:#75715e">// 存储当前节点所需要的 prevlen 大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 没有下一个节点，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (p[rawlen] <span style="color:#f92672">==</span> ZIP_END) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 获取 p 的下一个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">zipEntry</span>(p<span style="color:#f92672">+</span>rawlen, <span style="color:#f92672">&amp;</span>next);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果下一个节点的 prevlen 等于当前节点的 长度，则没必要更新，直接退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (next.prevrawlen <span style="color:#f92672">==</span> rawlen) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 下一个节点的 prevlen 小于当前节点的长度(当前节点长度为 5 字节，next 的 prevlen 为1 字节)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (next.prevrawlensize <span style="color:#f92672">&lt;</span> rawlensize) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ziplist的地址可能发生改变，先记录 p 相对于zl起始位置的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            offset <span style="color:#f92672">=</span> p<span style="color:#f92672">-</span>zl;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 额外需要申请的空间 5 - 1 = 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            extra <span style="color:#f92672">=</span> rawlensize<span style="color:#f92672">-</span>next.prevrawlensize;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 改变 ziplist 的容量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            zl <span style="color:#f92672">=</span> <span style="color:#a6e22e">ziplistResize</span>(zl,curlen<span style="color:#f92672">+</span>extra);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 重新计算 p 的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> zl<span style="color:#f92672">+</span>offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* Current pointer and offset for next element. */</span>
</span></span><span style="display:flex;"><span>            np <span style="color:#f92672">=</span> p<span style="color:#f92672">+</span>rawlen;  <span style="color:#75715e">// next 的新地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            noffset <span style="color:#f92672">=</span> np<span style="color:#f92672">-</span>zl;  <span style="color:#75715e">// next新地址相对于 ziplist 头部的偏移量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新 zltail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> ((zl<span style="color:#f92672">+</span><span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl))) <span style="color:#f92672">!=</span> np) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl) <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">intrev32ifbe</span>(<span style="color:#a6e22e">ZIPLIST_TAIL_OFFSET</span>(zl))<span style="color:#f92672">+</span>extra);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 扩展 next 的 prevlen，并将数据拷贝
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">memmove</span>(np<span style="color:#f92672">+</span>rawlensize,
</span></span><span style="display:flex;"><span>                np<span style="color:#f92672">+</span>next.prevrawlensize,
</span></span><span style="display:flex;"><span>                curlen<span style="color:#f92672">-</span>noffset<span style="color:#f92672">-</span>next.prevrawlensize<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 在扩展后的 next 的 prevlen 中重新记录 p 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">zipStorePrevEntryLength</span>(np,rawlen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/* Advance the cursor */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新 p 为下一个 entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p <span style="color:#f92672">+=</span> rawlen;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 更新 p 的长度(需要加上扩展的 prevlen 的 extra 个字节)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            curlen <span style="color:#f92672">+=</span> extra;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 这种情况下，next 的 prevlen 足够表示 当前 p 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (next.prevrawlensize <span style="color:#f92672">&gt;</span> rawlensize) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// next 的 prevlen &gt; p 的长度(next.prevlen = 5 结点，p的长度小于 5 个结点)，此时应该 缩容，但出于性能以及操作的方便性(减少后续连锁更新的可能性)，我们通常不进行缩容，这个时候，直接将 next 的 prevlen 设置为 5 个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">zipStorePrevEntryLengthLarge</span>(p<span style="color:#f92672">+</span>rawlen,rawlen);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 相等
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">zipStorePrevEntryLength</span>(p<span style="color:#f92672">+</span>rawlen,rawlen);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// next 的长度并没有发生变化(没有缩容)，终止循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> zl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解释【1】：“辅助结构体” <code>zlentry</code>，这个结构体与 <code>ziplist</code> 中的一个实际 <code>entry</code> 相对应，其作用是为了更加方便地操作一个 实际的 <code>entry</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> zlentry {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> prevrawlensize; <span style="color:#75715e">// 存储 prevrawlen 所需要的字节数，同样也有 1字节 和 5字节之分
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> prevrawlen;     <span style="color:#75715e">// 对应 prevlen
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> lensize;        <span style="color:#75715e">// 存储 len 所需要的字节数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len;            <span style="color:#75715e">// 当前 entry 的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> headersize;     <span style="color:#75715e">// ziplist头部大小: prevrawlensize + lensize
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> encoding;      <span style="color:#75715e">// 编码方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p;            <span style="color:#75715e">// 指向某个实际 entry 的地址
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} zlentry;
</span></span></code></pre></div><p><strong>其他的一些操作，比如删除、查找，过程与插入类似，无非就是各个 entry 地址的计算，删除时还有可能涉及到连锁更新。</strong> 这里不再描述，想了解的可以根据上面的思路自己研究源代码。</p>
<h4 id="63-总结">6.3 总结<a hidden class="anchor" aria-hidden="true" href="#63-总结">#</a></h4>
<ul>
<li><code>ziplist</code>是 redis 为了节省内存，提升存储效率自定义的一种紧凑的数据结构，每一个 <code>entry</code> 都保存这上一个 <code>entry</code> 的长度，可以很方便地进行反向遍历；</li>
<li>添加和删除节点可能会引发连锁更新，极端情况下会更新整个<code>ziplist</code>，但是概率很小；</li>
<li>在 <code>Redis</code> 中，当元素个数较少时，哈希表(<code>hset</code> 等操作) 和 列表(<code>lpush</code> 等操作) 的底层结构都是 <code>ziplist</code>。</li>
</ul>
<h3 id="7-紧凑列表">7. 紧凑列表<a hidden class="anchor" aria-hidden="true" href="#7-紧凑列表">#</a></h3>
<blockquote>
<p>源码文件：<a href="https://github.com/redis/redis/blob/unstable/src/listpack.h">listpack.h</a></p>
<p>实现文档：<a href="https://gist.github.com/antirez/66ffab20190ece8a7485bd9accfbc175">Listpack specification</a></p></blockquote>
<p>紧凑列表是 压缩列表 的升级版，目的是在未来代替 <code>ziplist</code>。</p>
<p>有时间再完善。</p>
<h2 id="二-redis-对象对应的数据结构">二、 <code>Redis</code> 对象对应的数据结构<a hidden class="anchor" aria-hidden="true" href="#二-redis-对象对应的数据结构">#</a></h2>
<p>前面大致介绍了 <strong>简单动态字符串 <code>sds</code></strong>、<strong>双端链表 <code>adlist</code></strong>、<strong>字典 <code>dict</code></strong>、<strong>跳表 <code>skiplist</code></strong>、<strong>整数集合 <code>intset</code></strong> 和 <strong>压缩列表 <code>ziplist</code></strong> 等基础数据结构，同时我们知道 <code>Redis</code> 中有 <strong>字符串对象(string)</strong>、<strong>列表对象(list)</strong>、<strong>哈希对象(hash)</strong>、<strong>集合对象(set)</strong> 和 <strong>有序集合对象(zset)</strong> 等五种对象，他们都至少用了上面一种基础数据结构来实现。在 <code>Redis</code> 中，客户端的一条命令以及参数会被解释成一个 <code>robj</code> 结构体：</p>
<blockquote>
<p>源码文件： <a href="%5Bziplist.h%5D(https://github.com/redis/redis/blob/unstable/src/server.h)">server.h</a></p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> type : <span style="color:#ae81ff">4</span>;       <span style="color:#75715e">// 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> encoding : <span style="color:#ae81ff">4</span>;	 <span style="color:#75715e">// 编码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> lru : LRU_BITS; <span style="color:#75715e">// 对象最后被访问的时间，我们暂时不关注 LRU
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> refcount;			 <span style="color:#75715e">// 引用次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;				 <span style="color:#75715e">// 指向实现对象的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} robj;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Object types */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_STRING 0 </span><span style="color:#75715e">/* String object. */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_LIST 1   </span><span style="color:#75715e">/* List object. */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_SET 2    </span><span style="color:#75715e">/* Set object. */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ZSET 3   </span><span style="color:#75715e">/* Sorted set object. */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_HASH 4   </span><span style="color:#75715e">/* Hash object. */</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Objects encoding. Some kind of objects like Strings and Hashes can be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * internally represented in multiple ways. The &#39;encoding&#39; field of the object
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * is set to one of this fields for this object. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define OBJ_ENCODING_RAW 0        </span><span style="color:#75715e">// 简单动态字符串 sds
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_INT 1        </span><span style="color:#75715e">// long 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_HT 2         </span><span style="color:#75715e">// 字典 dict
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_ZIPMAP 3     </span><span style="color:#75715e">// zipmap(弃用)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_LINKEDLIST 4 </span><span style="color:#75715e">// 双端链表 adlist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_ZIPLIST 5    </span><span style="color:#75715e">// 压缩列表 ziplist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_INTSET 6     </span><span style="color:#75715e">// 整数集合 intset
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_SKIPLIST 7   </span><span style="color:#75715e">// 跳表 skiplist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_EMBSTR 8     </span><span style="color:#75715e">// 采用embstr编码的sds
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_QUICKLIST 9  </span><span style="color:#75715e">// qunicklist，用于列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define OBJ_ENCODING_STREAM 10    </span><span style="color:#75715e">// 紧凑列表 listpack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define LRU_BITS 24
</span></span></span></code></pre></div><p><code>obj</code> 的作用大致为：</p>
<ul>
<li>为多种数据类型提供一种统一的表示方式。</li>
<li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li>
<li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li>
</ul>
<p>说到底， <code>robj</code> 所表示的就是 <strong>五种 <code>Object types</code></strong> 和 <strong>11 中 <code>Object encoding</code></strong> 之间的对应方式，起到一个桥梁作用。这种对应关系可用如下的图来表示：</p>
<p><img alt="Redis对象与数据结构对应关系" loading="lazy" src="https://pic.downk.cc/item/5f7a3a91160a154a67813577.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/redis/">Redis</a></li>
      <li><a href="http://localhost:1313/tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">基础数据结构</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">hujm2023&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
