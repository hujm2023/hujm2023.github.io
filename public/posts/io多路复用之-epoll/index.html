<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>I/O多路复用之 epoll | hujm2023&#39;s blog</title>
<meta name="keywords" content="Linux, 多路复用, epoll">
<meta name="description" content="select 的缺陷
目前对于高并发的解决方案是 一个线程处理所有连接，在这一点上 select 和 epoll 是一样的。但 当大量的并发连接存在、但短时间内只有少数活跃的连接时，select 的表现就显得捉襟见肘了。">
<meta name="author" content="JemmyHu(hujm20151021@gmail.com)">
<link rel="canonical" href="http://localhost:1313/posts/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css" integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn&#43;yY=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B9%8B-epoll/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="hujm2023&#39;s blog (Alt + H)">hujm2023&#39;s blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      I/O多路复用之 epoll
    </h1>
    <div class="post-meta"><span title='2021-05-10 20:57:47 +0800 CST'>May 10, 2021</span>&nbsp;·&nbsp;<span>JemmyHu(hujm20151021@gmail.com)</span>

</div>
  </header> 
<figure class="entry-cover">
        <img loading="eager" src="https://pic.downk.cc/item/5f61dc63160a154a6777224d.png" alt="">
        
</figure>
  <div class="post-content"><h2 id="select-的缺陷">select 的缺陷<a hidden class="anchor" aria-hidden="true" href="#select-的缺陷">#</a></h2>
<p>目前对于高并发的解决方案是 <strong>一个线程处理所有连接</strong>，在这一点上 <code>select</code> 和 <code>epoll</code> 是一样的。但 <strong>当大量的并发连接存在、但短时间内只有少数活跃的连接时，<code>select</code> 的表现就显得捉襟见肘了。</strong></p>
<p>首先，<code>select</code> 用在有活跃连接时，所以，在高并发的场景下 <code>select</code> 会被非常频繁地调用。当监听的连接以数万计的时候，每次返回的只是其中几百个活跃的连接，这本身就是一种性能的损失。所以内核中直接限定死了 <code>select</code> 可监听的文件句柄数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// include/uapi/linux/posix_types.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define __FD_SETSIZE  1024
</span></span></span></code></pre></div><p>其次，内核中实现 <code>select</code> 的方式是 <strong>轮询</strong>，即每次检测都会遍历所有的 <code>fd_set</code> 中的句柄，时间复杂度为 <code>O(n)</code>，与 <code>fd_set</code> 的长度呈线性关系，<code>select</code> 要检测的句柄数越多就会越费时。</p>
<blockquote>
<p><code>poll</code> 和 <code>select</code> 的实现机制没有太大差异，相比 <code>select</code>，<code>poll</code> 只是取消了最大监控文件描述符的限制，并没有从根本上解决 <code>select</code> 的缺陷。</p></blockquote>
<p>下面这张图中所表达的信息中，当并发连接较小时，<code>select</code> 和 <code>epoll</code> 差距非常小，当并发数逐渐变大时，<code>select</code> 性能就显得非常乏力：<br />
<img alt="主流IO多路复用机制benchmark" loading="lazy" src="https://user-images.githubusercontent.com/38834787/121148015-fad52900-c873-11eb-8c03-bbe885baa2bd.jpeg"></p>
<p>需要注意的是，这个前提是 <strong>保持大量连接，但是只有少数活跃连接</strong>，如果活跃连接也特别多，那 <code>epoll</code> 也会有性能问题。</p>
<h2 id="epoll-相关的数据结构与方法">epoll 相关的数据结构与方法<a hidden class="anchor" aria-hidden="true" href="#epoll-相关的数据结构与方法">#</a></h2>
<p>与 <code>epoll</code> 相关的系统调用有以下三个：</p>
<blockquote>
<p>这三个方法可以在 Linux 系统的机器上通过 <code>man 2 xxx</code> 的方式查看具体用法</p></blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/* 返回 epoll 实例的文件句柄，size 没有实际用途，传入一个大于 0 的数即可。 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_create</span>(<span style="color:#66d9ef">int</span> size);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 让 epoll(epfd)实例 对 目标文件(fd) 执行 `ADD | DEL | MOD` 操作，并指定”关心“的事件类型 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_ctl</span>(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">int</span> op, <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">struct</span> epoll_event <span style="color:#f92672">*</span>event);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 阻塞等待所”关心“的事件发生 */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">epoll_wait</span>(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">struct</span> epoll_event <span style="color:#f92672">*</span>events, <span style="color:#66d9ef">int</span> maxevents, <span style="color:#66d9ef">int</span> timeout);
</span></span></code></pre></div><p>与 <code>select</code> 相比，<code>epoll</code> 分清了 <strong>频繁调用</strong> 和 <strong>不频繁调用</strong> 的操作。例如，<code>epoll_ctl</code> 是不太频繁调用的，而 <code>epoll_wait</code> 是非常频繁调用的。</p>
<p>这是 <code>epoll</code> 最常见的 demo：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unistd.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sys/epoll.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>　　<span style="color:#66d9ef">int</span> epfd,nfds;
</span></span><span style="display:flex;"><span>　　<span style="color:#66d9ef">struct</span> epoll_event ev; <span style="color:#75715e">// ev用于注册事件，表示自己关心的事哪些事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> epoll_event events[<span style="color:#ae81ff">5</span>]; <span style="color:#75715e">// events 用于接收从内核返回的就绪事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>　　epfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">epoll_create</span>(<span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 创建一个 epoll 实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>　　ev.data.fd <span style="color:#f92672">=</span> STDIN_FILENO; <span style="color:#75715e">// 我们关心的是命令行输入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>　　ev.events <span style="color:#f92672">=</span> EPOLLIN<span style="color:#f92672">|</span>EPOLLET; <span style="color:#75715e">//监听读状态同时设置ET模式(这个后面会讲，可以简单理解成：文件内容发生变化时才会触发对应的事件)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>　　<span style="color:#a6e22e">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, STDIN_FILENO, <span style="color:#f92672">&amp;</span>ev); <span style="color:#75715e">// 注册epoll事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>　　<span style="color:#66d9ef">for</span>(;;)  
</span></span><span style="display:flex;"><span>　　{
</span></span><span style="display:flex;"><span>　　　　nfds <span style="color:#f92672">=</span> <span style="color:#a6e22e">epoll_wait</span>(epfd, events, <span style="color:#ae81ff">5</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// 进入死循环，最后的 -1 表示无限期阻塞，直到有事件发生
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>       <span style="color:#75715e">// epoll_wait 返回，表示有对应的事件发生，事件的信息存储在 events 数组中。nfds 表示数组的长度。接下来逐个处理事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>　　　　<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nfds; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>　　　　{
</span></span><span style="display:flex;"><span>　　　　　　<span style="color:#66d9ef">if</span>(events[i].data.fd<span style="color:#f92672">==</span>STDIN_FILENO)
</span></span><span style="display:flex;"><span>　　　　　　　　<span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;welcome to epoll&#39;s word!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>　　　　}
</span></span><span style="display:flex;"><span>　　}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接下来我们看看 <code>epoll</code> 相关的数据结构。</p>
<h3 id="eventpoll">eventpoll<a hidden class="anchor" aria-hidden="true" href="#eventpoll">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This structure is stored inside the &#34;private_data&#34; member of the file
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * structure and represents the main data structure for the eventpoll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * interface.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> eventpoll {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 保护 rbr(红黑树) 和 rdllist(等待队列) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> mutex mtx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 等待队列，用来保存对一个 epoll 实例调用 epoll_wait() 的所有进程。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 当调用 epoll_wait 的进程发现没有就绪的事件需要处理时，就将当前进程添加到此队列中，然后进程睡眠；后续事件发生，就唤醒这个队列中的所有进程(也就是出现了惊群效应)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wait_queue_head_t</span> wq;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当被监视的文件是一个 epoll 类型时，需要用这个等待队列来处理递归唤醒。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// epoll 也是一种文件类型，因此一个 epoll 类型的 fd 也是可以被其他 epoll 实例监视的。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 而 epoll 类型的 fd 只会有“读就绪”的事件。当 epoll 所监视的非 epoll 类型文件有“读就绪”事件时，当前 epoll 也会进入“读就绪”状态。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 因此如果一个 epoll 实例监视了另一个 epoll 就会出现递归。如 e2 监视了e1，e1 上有读就绪事件发生，e1 就会加入 e2 的 poll_wait 队列中。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wait_queue_head_t</span> poll_wait;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 就绪列表(双链表)，产生了用户注册的 fd读写事件的 epi 链表。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> list_head rdllist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 保护 rdllist 和 ovflist 。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">rwlock_t</span> lock;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* RB tree root used to store monitored fd structs */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 红黑树根结点，管理所有&#34;关心&#34;的 fd 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> rb_root_cached rbr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 单链表，当 rdllist 被锁定遍历向用户空间发送数据时，rdllist 不允许被修改，新触发的就绪 epitem 被 ovflist 串联起来，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 等待 rdllist 被处理完了，重新将 ovflist 数据写入 rdllist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>ovflist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* wakeup_source used when ep_scan_ready_list is running */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> wakeup_source <span style="color:#f92672">*</span>ws;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The user that created the eventpoll descriptor */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建 eventpoll 的用户结构信息。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> user_struct <span style="color:#f92672">*</span>user;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// eventpoll 对应的文件结构，Linux 中一切皆文件，epoll 也是一个文件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* used to optimize loop detection check */</span>
</span></span><span style="display:flex;"><span>    u64 gen;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> hlist_head refs;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>如上面 demo 中所示，</p>
<h3 id="epitem">epitem<a hidden class="anchor" aria-hidden="true" href="#epitem">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 红黑树用于管理所有的要监视的文件描述符 fd。当我们向系统中添加一个 fd 时，就会对应地创建一个 epitem 结构体。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// epitem 可以添加到红黑树，也可以串联成就绪列表或其它列表。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> epitem {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">union</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* RB tree node links this structure to the eventpoll RB tree */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 所在的红黑树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> rb_node rbn;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/* Used to free the struct epitem */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> rcu_head rcu;
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* List header used to link this structure to the eventpoll ready list */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 所在的 eventpoll 的就绪列表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> list_head rdllink;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Works together &#34;struct eventpoll&#34;-&gt;ovflist in keeping the single linked chain of items. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 关联的 eventpoll 中的 ovflist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The file descriptor information this item refers to */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 为最开始的 fd 创建 epitem 时的文件描述符信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> epoll_filefd ffd;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* List containing poll wait queues */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// poll 等待队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> eppoll_entry <span style="color:#f92672">*</span>pwqlist;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The &#34;container&#34; of this item */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 所在的 eventpoll 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* List header used to link this item to the &#34;struct file&#34; items list */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> hlist_node fllink;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* wakeup_source used when EPOLLWAKEUP is set */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> wakeup_source __rcu <span style="color:#f92672">*</span>ws;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The structure that describe the interested events and the source fd */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> epoll_event event;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h2 id="epoll-工作流程">epoll 工作流程<a hidden class="anchor" aria-hidden="true" href="#epoll-工作流程">#</a></h2>
<p><code>epoll</code> 是有状态的, 内核中维护了一个数据结构用来管理所要监视的 <code>fd</code>，这个数据结构是 <code>eventpoll</code>；<br />
在 <code>eventpoll</code> 中有一颗红黑树, 用来快速的查找和修改要监视的 <code>fd</code>，每个节点被封装成 <code>epitem</code> 结构；<br />
在 <code>eventpoll</code> 中有一个列表, 用来收集已经发生事件的 <code>epitem</code> , 这个 <code>list</code> 叫 <code>ready list(rdllist)</code>。</p>
<p>通过 <code>epoll_ctl</code> 函数添加进来的事件都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把事件添加进来的时候会完成关键的一步——该事件都会与相应的设备（网卡）驱动程序建立回调关系，当相应的事件发生后，就会调用这个回调函数，该回调函数在内核中被称为：<code>ep_poll_callback</code>。这个回调函数其实就所把这个事件添加到rdllist这个双向链表中——一旦有事件发生，epoll就会将该事件添加到双向链表中。那么当我们调用 <code>epoll_wait</code> 时，<code>epoll_wait</code> 只需要检查 <code>rdlist</code> 双向链表中是否有存在注册的事件，有则返回，效率非常可观。</p>
<h3 id="epoll_create-细节"><code>epoll_create</code> 细节<a hidden class="anchor" aria-hidden="true" href="#epoll_create-细节">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 创建一个 eventpoll 对象，并且关联文件资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_epoll_create</span>(<span style="color:#66d9ef">int</span> flags)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> error, fd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建并初始化核心结构 eventpoll，赋值给 ep
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    error <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_alloc</span>(<span style="color:#f92672">&amp;</span>ep);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (error <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个文件(文件句柄 fd 和 file结构)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">get_unused_fd_flags</span>(O_RDWR <span style="color:#f92672">|</span> (flags <span style="color:#f92672">&amp;</span> O_CLOEXEC));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fd <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        error <span style="color:#f92672">=</span> fd;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out_free_ep;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 注意，在这里将 eventpoll 作为 file 的 private_data 保存起来，后面拿到 epoll 的文件描述符后，通过 file.private_data 就能拿到绑定的 eventpoll 对象
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    file <span style="color:#f92672">=</span> <span style="color:#a6e22e">anon_inode_getfile</span>(<span style="color:#e6db74">&#34;[eventpoll]&#34;</span>, <span style="color:#f92672">&amp;</span>eventpoll_fops, ep,
</span></span><span style="display:flex;"><span>                 O_RDWR <span style="color:#f92672">|</span> (flags <span style="color:#f92672">&amp;</span> O_CLOEXEC));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">IS_ERR</span>(file)) {
</span></span><span style="display:flex;"><span>        error <span style="color:#f92672">=</span> <span style="color:#a6e22e">PTR_ERR</span>(file);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> out_free_fd;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 绑定 fd 和 file，这个 fd 就是 epoll 实例的句柄，需要返回给用户进程。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ep<span style="color:#f92672">-&gt;</span>file <span style="color:#f92672">=</span> file;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fd_install</span>(fd, file);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> fd;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>这个函数很简单，主要做以下几件事：</p>
<ol>
<li>创建并初始化核心结构 <code>eventpoll</code>，赋值给变量 <code>ep</code>；</li>
<li>创建一个 <code>文件句柄fd</code> 和 <code>文件 file结构体</code>，并绑定 <code>fd</code> 和 <code>file</code>、绑定 <code>file</code> 和 <code>eventpoll</code>(将 <code>eventpoll</code> 作为 <code>file</code> 的 <code>private_data</code> 保存起来，后面拿到 <code>epoll</code> 的文件描述符后，通过 <code>file.private_data</code> 就能拿到绑定的 <code>eventpoll</code> 对象)，这个 <code>fd</code> 就是 <code>epoll</code> 实例的句柄，需要返回给用户进程，这也间接说明 <code>epoll</code> 也是一种文件。</li>
</ol>
<blockquote>
<p>关于绑定 <code>fd</code> 和 <code>file</code>，参考：<a href="https://github.com/JemmyH/gogoredis/issues/6">彻底理解 Linux 中的 文件描述符(fd)</a></p></blockquote>
<h3 id="epoll_ctl-细节"><code>epoll_ctl</code> 细节<a hidden class="anchor" aria-hidden="true" href="#epoll_ctl-细节">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// epoll_ctl 的详细实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_epoll_ctl</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> epfd<span style="color:#75715e">/*epoll 文件描述符*/</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> op <span style="color:#75715e">/*操作类型*/</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd <span style="color:#75715e">/*要监控的目标文件描述符*/</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> epoll_event <span style="color:#f92672">*</span>epds<span style="color:#75715e">/*要监视的事件类型*/</span>, 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> nonblock,
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> error;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> full_check <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> fd f, tf;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>epi;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>tep <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// epoll 对应的文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> <span style="color:#a6e22e">fdget</span>(epfd);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// fd 对应的文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    tf <span style="color:#f92672">=</span> <span style="color:#a6e22e">fdget</span>(fd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The target file descriptor must support poll */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// epoll 并不能监控所有的文件描述符，只能监视支持 poll 方法的文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 其实是检查对应的 file 中的 file_operations 中是否有 poll 方法，即当前文件类型是否实现了 poll 方法(普通文件没有实现，socket 或者 epoll 类型等都实现了，所以可以被 epoll 监控)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">file_can_poll</span>(tf.file))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> error_tgt_fput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Check if EPOLLWAKEUP is allowed */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//  检查是否允许 EPOLLWAKEUP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">ep_op_has_event</span>(op))
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ep_take_care_of_epollwakeup</span>(epds);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// epoll 监视的不是自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    error <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (f.file <span style="color:#f92672">==</span> tf.file <span style="color:#f92672">||</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">is_file_epoll</span>(f.file))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> error_tgt_fput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 在 do_epoll_create 实现里 anon_inode_getfile 已经将 private_data 与 eventpoll 关联。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ep <span style="color:#f92672">=</span> f.file<span style="color:#f92672">-&gt;</span>private_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当我们添加进来的 file 是一个 epoll 类型的文件时，有可能造成循环引用的死循环。在这里提前检查避免这种情况 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    error <span style="color:#f92672">=</span> <span style="color:#a6e22e">epoll_mutex_lock</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>mtx, <span style="color:#ae81ff">0</span>, nonblock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (error)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> error_tgt_fput;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (op <span style="color:#f92672">==</span> EPOLL_CTL_ADD) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">READ_ONCE</span>(f.file<span style="color:#f92672">-&gt;</span>f_ep) <span style="color:#f92672">||</span> ep<span style="color:#f92672">-&gt;</span>gen <span style="color:#f92672">==</span> loop_check_gen <span style="color:#f92672">||</span> <span style="color:#a6e22e">is_file_epoll</span>(tf.file)) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查找 要添加的 fd 是否已经在红黑树上了，如果是，返回对应的 epitem 结构，否则返回 NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    epi <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_find</span>(ep, tf.file, fd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    error <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (op) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> EPOLL_CTL_ADD:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 增加fd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>epi) {
</span></span><span style="display:flex;"><span>            epds<span style="color:#f92672">-&gt;</span>events <span style="color:#f92672">|=</span> EPOLLERR <span style="color:#f92672">|</span> EPOLLHUP;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// fd 不在红黑树上，就将此 fd 添加到红黑树上管理。默认关注的事件是 EPOLLERR | EPOLLHUP
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            error <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_insert</span>(ep, epds, tf.file, fd, full_check);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            error <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EEXIST;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> EPOLL_CTL_DEL:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 删除fd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (epi)
</span></span><span style="display:flex;"><span>            error <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_remove</span>(ep, epi);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            error <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOENT;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> EPOLL_CTL_MOD:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 修改fd事件类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (epi) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLEXCLUSIVE)) {
</span></span><span style="display:flex;"><span>                epds<span style="color:#f92672">-&gt;</span>events <span style="color:#f92672">|=</span> EPOLLERR <span style="color:#f92672">|</span> EPOLLHUP;
</span></span><span style="display:flex;"><span>                error <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_modify</span>(ep, epi, epds);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            error <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ENOENT;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mutex_unlock</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>mtx);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>在 <code>do_epoll_ctl()</code> 的参数中，操作类型有三种：</p>
<ul>
<li><code>EPOLL_CTL_ADD</code>： 往事件表中注册fd上的事件；</li>
<li><code>EPOLL_CTL_DEL</code>：删除fd上的注册事件；</li>
<li><code>EPOLL_CTL_MOD</code>：修改fd上的注册事件。</li>
</ul>
<p>而 <code>struct epoll_event</code> 结构表示事件类型，常见的有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// eventpoll.h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLLIN  (__force __poll_t)0x00000001 </span><span style="color:#75715e">// 有可读数据到来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLLPRI (__force __poll_t)0x00000002 </span><span style="color:#75715e">// 有紧急数据可读：1. TCP socket 上有外带数据；2. 分布式环境下状态发生改变；3. cgroup.events类型的文件被修改
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLLOUT (__force __poll_t)0x00000004 </span><span style="color:#75715e">// 有数据要写
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLLERR (__force __poll_t)0x00000008 </span><span style="color:#75715e">// 文件描述符上发生错误(不管有没有设置这个 flag，epoll_wait 总是会检测并返回这样的错误)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLLHUP (__force __poll_t)0x00000010 </span><span style="color:#75715e">// 该文件描述符被挂断。常见 socket 被关闭（read == 0）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define EPOLLRDHUP (__force __poll_t)0x00002000 </span><span style="color:#75715e">// 对端已关闭链接，或者用 shutdown 关闭了写链
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Set the Edge Triggered behaviour for the target file descriptor */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define EPOLLET  ((__force __poll_t)(1U &lt;&lt; 31))  </span><span style="color:#75715e">// ET 工作模式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Set the One Shot behaviour for the target file descriptor */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 一般情况下，ET 模式只会触发一次，但有可能出现多个线程同时处理 epoll，此标志规定操作系统最多触发其上注册的一个可读或者可写或者异常事件，且只触发一次，如此无论线程再多，只能有一个线程或进程处理同一个描述符 */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define EPOLLONESHOT ((__force __poll_t)(1U &lt;&lt; 30)) 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Set exclusive wakeup mode for the target file descriptor */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* 唯一唤醒事件，主要为了解决 epoll_wait 惊群问题。多线程下多个 epoll_wait 同时等待，只唤醒一个 epoll_wait 执行。 该事件只支持 epoll_ctl 添加操作 EPOLL_CTL_ADD */</span> 
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define EPOLLEXCLUSIVE ((__force __poll_t)(1U &lt;&lt; 28))  
</span></span></span></code></pre></div><blockquote>
<p>关于什么是 “ET(边缘触发)” 和 “LT(水平触发)”，后面会详细说。</p></blockquote>
<h4 id="ep_insert">ep_insert<a hidden class="anchor" aria-hidden="true" href="#ep_insert">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ep_insert</span>(<span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> epoll_event <span style="color:#f92672">*</span>event, <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>tfile, <span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">int</span> full_check)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ep_insert(ep, epds, tf.file, fd, full_check);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// tf 表示 fd 对应的 file 结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> error, pwake <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    __poll_t revents;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> user_watches;  <span style="color:#75715e">// epoll 文件对象中所监视的 fd 数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>epi;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> ep_pqueue epq;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>tep <span style="color:#f92672">=</span> NULL;  <span style="color:#75715e">// 当 fd 类型是 epoll 时，tep 用来保存 fd 对应的 eventpoll 结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 要监视的文件也是 epoll 类型，用 tep 保存对应的 eventepoll 结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_file_epoll</span>(tfile))
</span></span><span style="display:flex;"><span>        tep <span style="color:#f92672">=</span> tfile<span style="color:#f92672">-&gt;</span>private_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lockdep_assert_irqs_enabled</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断 epoll 监视的文件个数是否超出系统限制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    user_watches <span style="color:#f92672">=</span> <span style="color:#a6e22e">atomic_long_read</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>user<span style="color:#f92672">-&gt;</span>epoll_watches);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(user_watches <span style="color:#f92672">&gt;=</span> max_user_watches))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOSPC;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(epi <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmem_cache_zalloc</span>(epi_cache, GFP_KERNEL)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Item initialization follow here ... */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个双链表，头和尾都是它自己
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">INIT_LIST_HEAD</span>(<span style="color:#f92672">&amp;</span>epi<span style="color:#f92672">-&gt;</span>rdllink);
</span></span><span style="display:flex;"><span>    epi<span style="color:#f92672">-&gt;</span>ep <span style="color:#f92672">=</span> ep;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ep_set_ffd</span>(<span style="color:#f92672">&amp;</span>epi<span style="color:#f92672">-&gt;</span>ffd, tfile, fd);  <span style="color:#75715e">// epitem 与 fd 绑定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    epi<span style="color:#f92672">-&gt;</span>event <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>event;
</span></span><span style="display:flex;"><span>    epi<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> EP_UNACTIVE_PTR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 目标文件是 epoll 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (tep)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mutex_lock_nested</span>(<span style="color:#f92672">&amp;</span>tep<span style="color:#f92672">-&gt;</span>mtx, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Add the current item to the list of active epoll hook for this file */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(<span style="color:#a6e22e">attach_epitem</span>(tfile, epi) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">kmem_cache_free</span>(epi_cache, epi);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (tep)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">mutex_unlock</span>(<span style="color:#f92672">&amp;</span>tep<span style="color:#f92672">-&gt;</span>mtx);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (full_check <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>tep)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">list_file</span>(tfile);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 当前进程的用户的 epoll_watches 加一
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">atomic_long_inc</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>user<span style="color:#f92672">-&gt;</span>epoll_watches);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将初始化后的 epitem 添加到红黑树中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ep_rbtree_insert</span>(ep, epi);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (tep)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">mutex_unlock</span>(<span style="color:#f92672">&amp;</span>tep<span style="color:#f92672">-&gt;</span>mtx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不允许递归监视太多的 epoll 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">unlikely</span>(full_check <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">reverse_path_check</span>())) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ep_remove</span>(ep, epi);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLWAKEUP) {
</span></span><span style="display:flex;"><span>        error <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_create_wakeup_source</span>(epi);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (error) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ep_remove</span>(ep, epi);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Initialize the poll table using the queue callback */</span>
</span></span><span style="display:flex;"><span>    epq.epi <span style="color:#f92672">=</span> epi;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 注册回调函数，作用：add our wait queue to the target file wakeup lists. 在tcp_sock-&gt;sk_sleep中插入一个等待者
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 不同的系统实现 poll 的方式不同，如socket的话, 那么这个接口就是 tcp_poll()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">init_poll_funcptr</span>(<span style="color:#f92672">&amp;</span>epq.pt, ep_ptable_queue_proc); 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 可能此时已经有事件存在了, revents返回这个事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    revents <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_item_poll</span>(epi, <span style="color:#f92672">&amp;</span>epq.pt, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果此时就有关注的事件发生，我们将其放到就绪队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (revents <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">ep_is_linked</span>(epi)) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">list_add_tail</span>(<span style="color:#f92672">&amp;</span>epi<span style="color:#f92672">-&gt;</span>rdllink, <span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>rdllist);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ep_pm_stay_awake</span>(epi);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 唤醒等待的线程，告诉他们有活干了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">waitqueue_active</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>wq))
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">wake_up</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>wq);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">waitqueue_active</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>poll_wait))
</span></span><span style="display:flex;"><span>            pwake<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><code>ep_insert</code> 先申请一个 <code>epitem</code> 对象 <code>epi</code>，并初始化 <code>epitem</code> 的两个 <code>list</code> 的头指针：<code>rdllink</code>(指向 <code>eventpoll</code> 的 <code>rdllist</code>)、<code>pwqlist</code>(指向包含此 <code>epitem</code> 的所有 <code>poll wait queue</code>)，通过 <code>fs</code> 将 <code>epitem</code>、<code>fd</code> 和 <code>file</code> 绑定，通过 <code>epitem.ep</code> 将此 <code>epitem</code> 和 传入的 <code>eventpoll</code> 对象绑定，通过传入的 <code>event</code> 对 <code>epitem.events</code> 赋值，紧接着，将这个 <code>epitem</code> 加入到 <code>eventpoll</code> 的 红黑树中。整个过程结束后，<code>epitem</code> 本身就完成了和 <code>eventpoll</code> 以及 <code>被监视文件fd</code> 的关联。但还要做一件事：将 <code>epitem</code> 加入目标文件的 <code>poll</code> 等待队列并注册对应的回调函数。</p>
<p>在 <code>ep_insert()</code> 中有一行是 <code>init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</code>，这其实是注册了一个回调函数——将文件的 <code>poll()</code> 方法与此方法绑定，当文件就绪，就会调用此方法。</p>
<blockquote>
<p>关于 <strong>等待队列</strong> 的实现，参考：<a href="https://github.com/JemmyH/gogoredis/issues/7">理解 Linux 等待队列</a></p></blockquote>
<p>我们知道，当一个进程加入等待队列之后，需要将设置对应的唤醒函数，当资源就绪的时候调用这个设置好的唤醒函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 链表中的一个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> wait_queue_entry {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>  flags; <span style="color:#75715e">// 标志，如 WQ_FLAG_EXCLUSIVE，表示等待的进程应该独占资源（解决惊群现象）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span>   <span style="color:#f92672">*</span>private;  <span style="color:#75715e">// 等待进程相关信息，如 task_struct
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">wait_queue_func_t</span> func; <span style="color:#75715e">// 唤醒函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> list_head entry; <span style="color:#75715e">// 前后结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>我们再来看下 <code>init_waitqueue_func_entry</code> 这个方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_waitqueue_func_entry</span>(<span style="color:#66d9ef">struct</span> wait_queue_entry <span style="color:#f92672">*</span>wq_entry, <span style="color:#66d9ef">wait_queue_func_t</span> func)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    wq_entry<span style="color:#f92672">-&gt;</span>flags  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    wq_entry<span style="color:#f92672">-&gt;</span>private <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    wq_entry<span style="color:#f92672">-&gt;</span>func  <span style="color:#f92672">=</span> func;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>正是将等待队列中的结点的唤醒函数设置为 <code>ep_ptable_queue_proc</code> ！</p>
<p>我们来详细看看 <code>ep_ptable_queue_proc</code> 的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 当该文件描述符对应的文件有事件到达后，回调用这个函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 首先根据pt拿到对应的epi。然后通过pwq将三者关联。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// @file: 要监听的文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// @whead: 该fd对应的设备等待队列，每个设备的驱动都会带
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// @pt: 调用文件的poll传入的东西。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ep_ptable_queue_proc</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file, <span style="color:#66d9ef">wait_queue_head_t</span> <span style="color:#f92672">*</span>whead,
</span></span><span style="display:flex;"><span>                 poll_table <span style="color:#f92672">*</span>pt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> ep_pqueue <span style="color:#f92672">*</span>epq <span style="color:#f92672">=</span> <span style="color:#a6e22e">container_of</span>(pt, <span style="color:#66d9ef">struct</span> ep_pqueue, pt);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>epi <span style="color:#f92672">=</span> epq<span style="color:#f92672">-&gt;</span>epi;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> eppoll_entry <span style="color:#f92672">*</span>pwq;  <span style="color:#75715e">// epitem 的私有项，为每一个 fd 保存内核的 poll。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这个结构体主要完成 epitem 和 epitem事件发生时 callback 函数的关联，将唤醒回调函数设置为 ep_poll_callback，然后加入设备等待队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将pwq的等待队列和回调函数ep_poll_callback关联
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// ep_poll_callback 才是真正意义上的 poll() 醒来时的回调函数，当设备就绪，就会唤醒设备的等待队列中的进程，此时 ep_poll_callback 会被调用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">init_waitqueue_func_entry</span>(<span style="color:#f92672">&amp;</span>pwq<span style="color:#f92672">-&gt;</span>wait, ep_poll_callback);
</span></span><span style="display:flex;"><span>    pwq<span style="color:#f92672">-&gt;</span>whead <span style="color:#f92672">=</span> whead;
</span></span><span style="display:flex;"><span>    pwq<span style="color:#f92672">-&gt;</span>base <span style="color:#f92672">=</span> epi;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 进程对应的等待双链表结点 放入等待队列whead
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 将eppoll_entry挂在到fd的设备等待队列上。也就是注册epoll的回调函数 ep_poll_callback
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLEXCLUSIVE)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">add_wait_queue_exclusive</span>(whead, <span style="color:#f92672">&amp;</span>pwq<span style="color:#f92672">-&gt;</span>wait);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">add_wait_queue</span>(whead, <span style="color:#f92672">&amp;</span>pwq<span style="color:#f92672">-&gt;</span>wait);
</span></span><span style="display:flex;"><span>    pwq<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> epi<span style="color:#f92672">-&gt;</span>pwqlist;
</span></span><span style="display:flex;"><span>    epi<span style="color:#f92672">-&gt;</span>pwqlist <span style="color:#f92672">=</span> pwq;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们来看看 <code>ep_poll_callback</code> 干了什么：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This is the callback that is passed to the wait queue wakeup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * mechanism. It is called by the stored file descriptors when they
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * have events to report.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * This callback takes a read lock in order not to contend with concurrent
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * events from another file descriptor, thus all modifications to -&gt;rdllist
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * or -&gt;ovflist are lockless.  Read lock is paired with the write lock from
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ep_scan_ready_list(), which stops all list modifications and guarantees
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * that lists state is seen correctly.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ep_poll_callback</span>(<span style="color:#66d9ef">wait_queue_entry_t</span> <span style="color:#f92672">*</span>wait, <span style="color:#66d9ef">unsigned</span> mode, <span style="color:#66d9ef">int</span> sync, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pwake <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>epi <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_item_from_wait</span>(wait);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep <span style="color:#f92672">=</span> epi<span style="color:#f92672">-&gt;</span>ep;
</span></span><span style="display:flex;"><span>    __poll_t pollflags <span style="color:#f92672">=</span> <span style="color:#a6e22e">key_to_poll</span>(key);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> ewake <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * If we are transferring events to userspace, we can hold no locks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * (because we&#39;re accessing user memory, and because of linux f_op-&gt;poll()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * semantics). All the events that happen during that period of time are
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * chained in ep-&gt;ovflist and requeued later on.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 因为要访问用户空间，所以此时对 rdllist 的访问不应该加锁。如果恰巧这个时候有对应的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 事件发生，应该将其放到 ovflist 中之后再调度。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">READ_ONCE</span>(ep<span style="color:#f92672">-&gt;</span>ovflist) <span style="color:#f92672">!=</span> EP_UNACTIVE_PTR) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">chain_epi_lockless</span>(epi))
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ep_pm_stay_awake_rcu</span>(epi);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">ep_is_linked</span>(epi)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将当前的 epitem 添加到 eventpool 的就绪队列中 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">/* In the usual case, add event to ready list. */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">list_add_tail_lockless</span>(<span style="color:#f92672">&amp;</span>epi<span style="color:#f92672">-&gt;</span>rdllink, <span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>rdllist))
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ep_pm_stay_awake_rcu</span>(epi);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * wait list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 同时唤醒 eventpool 和 poll 的等待的进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">waitqueue_active</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>wq)) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ((epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLEXCLUSIVE) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">!</span>(pollflags <span style="color:#f92672">&amp;</span> POLLFREE)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">switch</span> (pollflags <span style="color:#f92672">&amp;</span> EPOLLINOUT_BITS) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> EPOLLIN:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLIN)
</span></span><span style="display:flex;"><span>                    ewake <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> EPOLLOUT:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLOUT)
</span></span><span style="display:flex;"><span>                    ewake <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>                ewake <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wake_up</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>wq);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">waitqueue_active</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>poll_wait))
</span></span><span style="display:flex;"><span>        pwake<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ewake;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="ep_wait-细节"><code>ep_wait</code> 细节<a hidden class="anchor" aria-hidden="true" href="#ep_wait-细节">#</a></h3>
<p>入口在</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">SYSCALL_DEFINE4</span>(epoll_wait, <span style="color:#66d9ef">int</span>, epfd, <span style="color:#66d9ef">struct</span> epoll_event __user <span style="color:#f92672">*</span>, events,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span>, maxevents, <span style="color:#66d9ef">int</span>, timeout)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> timespec64 to;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">do_epoll_wait</span>(epfd, events, maxevents,
</span></span><span style="display:flex;"><span>                 <span style="color:#a6e22e">ep_timeout_to_timespec</span>(<span style="color:#f92672">&amp;</span>to, timeout));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>实际调用的是 <code>do_epoll_wait</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Implement the event wait interface for the eventpoll file. It is the kernel
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * part of the user space epoll_wait(2).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @epfd: 对应的 eventpoll 文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @events:  用于接收已经就绪的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @maxevents：所监听的最大事件个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @to：超时事件(-1表示无限制等待)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// epoll_wait 的具体实现
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_epoll_wait</span>(<span style="color:#66d9ef">int</span> epfd, <span style="color:#66d9ef">struct</span> epoll_event __user <span style="color:#f92672">*</span>events,
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">int</span> maxevents, <span style="color:#66d9ef">struct</span> timespec64 <span style="color:#f92672">*</span>to)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> error;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> fd f;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* The maximum number of event must be greater than zero */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (maxevents <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> maxevents <span style="color:#f92672">&gt;</span> EP_MAX_EVENTS)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Verify that the area passed by the user is writeable */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 确保用户传进来的地址空间是可写的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">access_ok</span>(events, maxevents <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> epoll_event)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Get the &#34;struct file *&#34; for the eventpoll file */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取 epoll 实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    f <span style="color:#f92672">=</span> <span style="color:#a6e22e">fdget</span>(epfd);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>f.file)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EBADF;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * We have to check that the file structure underneath the fd
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * the user passed to us _is_ an eventpoll file.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    error <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 确保传进来的 epfd 是 epoll 类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">is_file_epoll</span>(f.file))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">goto</span> error_fput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * At this point it is safe to assume that the &#34;private_data&#34; contains
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * our own data structure.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    ep <span style="color:#f92672">=</span> f.file<span style="color:#f92672">-&gt;</span>private_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Time to fish for events ... */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 执行具体的 poll，如果有事件产生，返回的 error 就是对应的事件个数，对应的事件也会同时从 eventpoll 对应的 rdllist(就绪队列) 中写入到传进来的 events 数组中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    error <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_poll</span>(ep, events, maxevents, to);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error_fput:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fdput</span>(f);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> error;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们看下 <code>ep_poll</code> 的实现细节：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * ep_poll - 检索已经就绪的事件，并将其从内核空间传送到用户空间传进来的events 列表中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @ep: eventpoll 实例指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @events: 存放就绪事件的用户空间的数组的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @maxevents: events 数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @timeout: 获取就绪事件操作的最大超时时间。如果是 0，表示不阻塞；如果是负数，表示一直阻塞
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Return: 成功收到的事件的个数，或者失败时对应的错误码。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ep_poll</span>(<span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep, <span style="color:#66d9ef">struct</span> epoll_event __user <span style="color:#f92672">*</span>events,
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">int</span> maxevents, <span style="color:#66d9ef">struct</span> timespec64 <span style="color:#f92672">*</span>timeout)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res, eavail, timed_out <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    u64 slack <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">wait_queue_entry_t</span> wait;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ktime_t</span> expires, <span style="color:#f92672">*</span>to <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">lockdep_assert_irqs_enabled</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (timeout <span style="color:#f92672">&amp;&amp;</span> (timeout<span style="color:#f92672">-&gt;</span>tv_sec <span style="color:#f92672">|</span> timeout<span style="color:#f92672">-&gt;</span>tv_nsec)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 有具体的超时时长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        slack <span style="color:#f92672">=</span> <span style="color:#a6e22e">select_estimate_accuracy</span>(timeout);
</span></span><span style="display:flex;"><span>        to <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>expires;
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>to <span style="color:#f92672">=</span> <span style="color:#a6e22e">timespec64_to_ktime</span>(<span style="color:#f92672">*</span>timeout);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (timeout) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Avoid the unnecessary trip to the wait queue loop, if the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * caller specified a non blocking operation.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 用户设置不阻塞。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        timed_out <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查 ep.rdllist 或 ep.ovflist 中是否有就绪的事件，如果有返回就绪事件的个数。否则返回 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    eavail <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_events_available</span>(ep);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (eavail) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// rdllist 中已经有事件了，将其传送到用户空间。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 如果没有对应的事件并且也没到超时时间，就再等等，直到超时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            res <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_send_events</span>(ep, events, maxevents);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (res)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 走到这一步，说明没有就绪事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 用户设置不阻塞，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (timed_out)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// always false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        eavail <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_busy_loop</span>(ep, timed_out);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (eavail)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查当前进程是否有信号处理，返回不为0表示有信号需要处理。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">signal_pending</span>(current))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINTR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">init_wait</span>(<span style="color:#f92672">&amp;</span>wait);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">write_lock_irq</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__set_current_state</span>(TASK_INTERRUPTIBLE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 再次检查是否有就绪事件，如果没有，让当前进程睡眠(然后进程就阻塞在这里了...)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        eavail <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_events_available</span>(ep);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>eavail)
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">__add_wait_queue_exclusive</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>wq, <span style="color:#f92672">&amp;</span>wait);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">write_unlock_irq</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 重新计算超时时间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>eavail)
</span></span><span style="display:flex;"><span>            timed_out <span style="color:#f92672">=</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">schedule_hrtimeout_range</span>(to, slack,
</span></span><span style="display:flex;"><span>                                  HRTIMER_MODE_ABS);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 进程被唤醒了，说明有事件发生！          
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">__set_current_state</span>(TASK_RUNNING);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * We were woken up, thus go and try to harvest some events.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * If timed out and still on the wait queue, recheck eavail
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * carefully under lock, below.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        eavail <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">list_empty_careful</span>(<span style="color:#f92672">&amp;</span>wait.entry)) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">write_lock_irq</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * If the thread timed out and is not on the wait queue,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * it means that the thread was woken up after its
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * timeout expired before it could reacquire the lock.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * Thus, when wait.entry is empty, it needs to harvest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * events.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (timed_out)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// list_empty 检查 list 是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                eavail <span style="color:#f92672">=</span> <span style="color:#a6e22e">list_empty</span>(<span style="color:#f92672">&amp;</span>wait.entry);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 将 wait 从 ep 的等待队列中删除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">__remove_wait_queue</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>wq, <span style="color:#f92672">&amp;</span>wait);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">write_unlock_irq</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们再来看 <code>ep_send_events</code>的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">ep_send_events</span>(<span style="color:#66d9ef">struct</span> eventpoll <span style="color:#f92672">*</span>ep,
</span></span><span style="display:flex;"><span>              <span style="color:#66d9ef">struct</span> epoll_event __user <span style="color:#f92672">*</span>events, <span style="color:#66d9ef">int</span> maxevents)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>epi, <span style="color:#f92672">*</span>tmp;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">LIST_HEAD</span>(txlist);
</span></span><span style="display:flex;"><span>    poll_table pt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fatal_signal_pending</span>(current))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINTR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">init_poll_funcptr</span>(<span style="color:#f92672">&amp;</span>pt, NULL);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mutex_lock</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>mtx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将 rdllist 中的元素全部添加到 txlist 中，并清空 ep.rdllist 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ep_start_scan</span>(ep, <span style="color:#f92672">&amp;</span>txlist);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 迭代器，逐个处理从 ep-&gt;rdllist 中取出后放在 txlist 中的 epitem 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// epi 表示正在处理的对象(cursor)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">list_for_each_entry_safe</span>(epi, tmp, <span style="color:#f92672">&amp;</span>txlist, rdllink) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> wakeup_source <span style="color:#f92672">*</span>ws;
</span></span><span style="display:flex;"><span>        __poll_t revents;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (res <span style="color:#f92672">&gt;=</span> maxevents)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ws <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_wakeup_source</span>(epi);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ws) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (ws<span style="color:#f92672">-&gt;</span>active)
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">__pm_stay_awake</span>(ep<span style="color:#f92672">-&gt;</span>ws);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">__pm_relax</span>(ws);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 重置 epitem 中的 rdllink
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">list_del_init</span>(<span style="color:#f92672">&amp;</span>epi<span style="color:#f92672">-&gt;</span>rdllink);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查就绪事件的 flag 是否是调用方需要的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        revents <span style="color:#f92672">=</span> <span style="color:#a6e22e">ep_item_poll</span>(epi, <span style="color:#f92672">&amp;</span>pt, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>revents)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 内核向用户态复制数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">__put_user</span>(revents, <span style="color:#f92672">&amp;</span>events<span style="color:#f92672">-&gt;</span>events) <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">__put_user</span>(epi<span style="color:#f92672">-&gt;</span>event.data, <span style="color:#f92672">&amp;</span>events<span style="color:#f92672">-&gt;</span>data)) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list_add</span>(<span style="color:#f92672">&amp;</span>epi<span style="color:#f92672">-&gt;</span>rdllink, <span style="color:#f92672">&amp;</span>txlist);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ep_pm_stay_awake</span>(epi);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>res)
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        res<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        events<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 处理水平触发和边缘触发的场景
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLONESHOT)
</span></span><span style="display:flex;"><span>            epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;=</span> EP_PRIVATE_BITS;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(epi<span style="color:#f92672">-&gt;</span>event.events <span style="color:#f92672">&amp;</span> EPOLLET)) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">list_add_tail</span>(<span style="color:#f92672">&amp;</span>epi<span style="color:#f92672">-&gt;</span>rdllink, <span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>rdllist);
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">ep_pm_stay_awake</span>(epi);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ep_done_scan</span>(ep, <span style="color:#f92672">&amp;</span>txlist);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">mutex_unlock</span>(<span style="color:#f92672">&amp;</span>ep<span style="color:#f92672">-&gt;</span>mtx);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>而其中的 <code>ep_item_poll</code>，不同的驱动程序，都会有自己的 <code>poll</code> 方法，如果是 <code>TCP套接字</code>，这个<code>poll</code>方法就是 <code>tcp_poll</code>。在 <code>TCP</code> 中，会周期性的调用这个方法调用频率取决于协议栈中断频率的设置。一旦有事件到达后，对应的 <code>tcp_poll</code> 方法被调用，<code>tcp_poll</code> 方法会回调用 <code>sock_poll_wait()</code>，该方法会调用这里注册的 <code>ep_ptable_queue_proc</code> 方法。<code>epoll</code> 其实就是通过此机制实现将自己的回调函数加入到文件的 <code>waitqueue</code> 中的。这也是 <code>ep_ptable_queue_proc</code> 的目的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __poll_t <span style="color:#a6e22e">ep_item_poll</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> epitem <span style="color:#f92672">*</span>epi, poll_table <span style="color:#f92672">*</span>pt,
</span></span><span style="display:flex;"><span>                 <span style="color:#66d9ef">int</span> depth)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>file <span style="color:#f92672">=</span> epi<span style="color:#f92672">-&gt;</span>ffd.file;
</span></span><span style="display:flex;"><span>    __poll_t res;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    pt<span style="color:#f92672">-&gt;</span>_key <span style="color:#f92672">=</span> epi<span style="color:#f92672">-&gt;</span>event.events;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">is_file_epoll</span>(file))
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 非 epoll 类型的 fd，检查 socket 的就绪事件，fd 关联回调函数 ep_poll_callback。最终执行的 poll 是 tcp_poll
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        res <span style="color:#f92672">=</span> <span style="color:#a6e22e">vfs_poll</span>(file, pt);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> <span style="color:#a6e22e">__ep_eventpoll_poll</span>(file, pt, depth);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res <span style="color:#f92672">&amp;</span> epi<span style="color:#f92672">-&gt;</span>event.events;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="再谈-epoll-和-select">再谈 <code>epoll</code> 和 <code>select</code><a hidden class="anchor" aria-hidden="true" href="#再谈-epoll-和-select">#</a></h2>
<p>从更高的角度看，<code>epoll</code> 和 <code>select</code> 都是 <code>I/O 多路复用</code>，当我们在调用这类函数时，我们传入的是 <strong>关心的socket</strong>，接收到的返回是 <strong>就绪的 socket</strong>。那为何会有性能差距呢？我们尝试找出他们的不同点：</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">对比</th>
          <th style="text-align: center">select</th>
          <th style="text-align: center">epoll</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">连接数限制</td>
          <td style="text-align: center">1024</td>
          <td style="text-align: center">理论上无限制</td>
      </tr>
      <tr>
          <td style="text-align: center">内在处理机制</td>
          <td style="text-align: center">现行轮训</td>
          <td style="text-align: center">callback</td>
      </tr>
      <tr>
          <td style="text-align: center">TODO</td>
          <td style="text-align: center">TODO</td>
          <td style="text-align: center">TODO</td>
      </tr>
  </tbody>
</table>
<p>再回头看看 <code>select</code> 的 demo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fds[] <span style="color:#f92672">=</span> ...;  <span style="color:#75715e">// 关心的 socket 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fd_set source_fds; <span style="color:#75715e">// 将我们关心的 socket 保存到 fd_set 中 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fd_set temp_fds; <span style="color:#75715e">// 临时变量，作为 select 的返回值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化 source_fds
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">FD_ZERO</span>(<span style="color:#f92672">&amp;</span>source_fds);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>fds.length; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">FD_SET</span>(fds[i], <span style="color:#f92672">&amp;</span>source_fds);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// select 将一个 fd_set 作为入参，将就绪的 socket 又填充如这个入参中作为出参返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 因此，为了快速重置，设置一个临时变量，避免每次都要进行 source_fds 的重置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        temp_fds <span style="color:#f92672">=</span> source_fds;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// select 会阻塞，直到关心的 socket 上有事件发生
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#a6e22e">select</span>(..., <span style="color:#f92672">&amp;</span>temp_fds, ...);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 在用户态遍历 socket，检查是否有我们关心的事件发生
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> fds.length; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">FD_ISSET</span>(fds[i], <span style="color:#f92672">&amp;</span>temp_fds)) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// ... 进行对应的逻辑处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#a6e22e">FD_CLR</span>(fds[i], <span style="color:#f92672">&amp;</span>temp_fds);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>select</code> 主要有两点限制：</p>
<ol>
<li>所能关注的 socket 太少，只能有 1024 个，对于一些大型 web 应用来说有点捉襟见肘；</li>
<li>尽管 <code>FD_SET</code> 是 <code>O(1)</code> 的操作，但返回后还要在用户态遍历一次整个 <code>fd_set</code>，这是一个线性操作</li>
</ol>
<p>再回过头来看 <code>epoll</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fds[] <span style="color:#f92672">=</span> ...;  <span style="color:#75715e">// 关心的 socket 数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> epfd <span style="color:#f92672">=</span> <span style="color:#a6e22e">epoll_create</span>(...); <span style="color:#75715e">// 创建 epoll 实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 将关心的 socket 添加到 epoll 中(红黑树等)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> fds.length; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">epoll_ctl</span>(epfd,EPOLL_CTL_ADD, fds[i], ...);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 定义一个结构，用来接收就绪的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> epoll_event events[MAX_EVENTS];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果无事件发生，那么进程将阻塞在这里
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 如果有事件发生，则返回就绪的事件个数，同时事件被存储在 events 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#a6e22e">epoll_wait</span>(epfd, <span style="color:#f92672">&amp;</span>events,...);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 通过下标取到返回的就绪事件，进行对应的逻辑处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            new_event <span style="color:#f92672">=</span> events[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>每次<code>epoll_wait</code> 返回的都是活跃的 socket，根本不用全部遍历一遍</li>
<li><code>epoll</code> 底层使用到了 <strong>红黑树</strong> 来存储所关心的 <code>socket</code>，查找效率有保证；注册的对应的事件通知是通过回调的方式执行的，这种解耦、相互协作的方式更有利于操作系统的调度。</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/linux/">Linux</a></li>
      <li><a href="http://localhost:1313/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">多路复用</a></li>
      <li><a href="http://localhost:1313/tags/epoll/">Epoll</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">hujm2023&#39;s blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
