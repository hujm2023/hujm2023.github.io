<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Golang on hujm2023&#39;s blog</title>
    <link>http://localhost:1313/categories/golang/</link>
    <description>Recent content in Golang on hujm2023&#39;s blog</description>
    <generator>Hugo -- 0.151.0</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 03 May 2021 21:00:42 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux面试汇总</title>
      <link>http://localhost:1313/posts/linux%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 03 May 2021 21:00:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/linux%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</guid>
      <description>&lt;h2 id=&#34;进程调度&#34;&gt;进程调度&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;进程调度算法&lt;/strong&gt; 也称 &lt;strong&gt;CPU 调度算法&lt;/strong&gt;，毕竟进程是有 &lt;code&gt;CPU&lt;/code&gt; 进行调度的。当 &lt;code&gt;CPU&lt;/code&gt; 空闲时，操作系统就会选择内存中某个处在 &lt;code&gt;就绪状态&lt;/code&gt; 的进程，分配给其 &lt;code&gt;CPU&lt;/code&gt; 开始运行。&lt;/p&gt;
&lt;p&gt;进程一般有三种基本状态：&lt;code&gt;运行&lt;/code&gt;、&lt;code&gt;就绪&lt;/code&gt; 和 &lt;code&gt;阻塞&lt;/code&gt;，还有一种说法，还包括 &lt;code&gt;新建&lt;/code&gt; 和 &lt;code&gt;终止&lt;/code&gt;。它们叫做 &lt;strong&gt;五态模型&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang面试汇总</title>
      <link>http://localhost:1313/posts/golang%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</link>
      <pubDate>Sat, 01 May 2021 20:57:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB/</guid>
      <description>&lt;!-- @format --&gt;
&lt;h2 id=&#34;进程线程-和-协程&#34;&gt;进程、线程 和 协程&lt;/h2&gt;</description>
    </item>
    <item>
      <title>Golang Channel详解</title>
      <link>http://localhost:1313/posts/golang-channel%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 09 Apr 2021 11:57:42 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang-channel%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;一原理&#34;&gt;一、原理&lt;/h2&gt;
&lt;h3 id=&#34;0-简介&#34;&gt;0. 简介&lt;/h3&gt;
&lt;p&gt;channel 分为有缓冲和无缓冲，或者阻塞和非阻塞，主要区别就在于是否有 &lt;code&gt;容量capacity&lt;/code&gt;。&lt;br /&gt;
在 &lt;code&gt;runtime&lt;/code&gt; 中是通过 &lt;code&gt;hchan&lt;/code&gt; 这个结构体来表示的，它里面的主要成员可以理解成包含两个大部分：环形队列相关 和 sudog等待队列 相关。&lt;br /&gt;
对于有缓冲的 channel，会设置环形队列相关的参数，如已有的元素数量、容量、指向队列的指针等；&lt;br /&gt;
等待队列有发送等待队列和接受等待队列，他们分别在发送时 channel 已满、接收时 channel 为空的情况下，会将当前 goroutine 打包成一个 sudog 结构，添加到对应的队列中，直到条件符合时再被唤醒工作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang中使用RSA进行加解密</title>
      <link>http://localhost:1313/posts/golang%E4%B8%AD%E4%BD%BF%E7%94%A8rsa%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E5%AF%86/</link>
      <pubDate>Thu, 14 Jan 2021 11:45:06 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang%E4%B8%AD%E4%BD%BF%E7%94%A8rsa%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%A7%A3%E5%AF%86/</guid>
      <description>&lt;!-- @format --&gt;
&lt;p&gt;本文对 RSA 加密算法 的细节不做深究，仅描述大致用法。具体算法原理请阅读参考文献中的 2 和 4。&lt;/p&gt;
&lt;h2 id=&#34;一介绍&#34;&gt;一、介绍&lt;/h2&gt;
&lt;p&gt;当我们谈论加解密方式时，通常有两种情形：&lt;strong&gt;对称加密&lt;/strong&gt; 和 &lt;strong&gt;非对称加密&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Boltdb使用(一)基本用法</title>
      <link>http://localhost:1313/posts/boltdb%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <pubDate>Tue, 05 Jan 2021 16:28:43 +0800</pubDate>
      <guid>http://localhost:1313/posts/boltdb%E4%BD%BF%E7%94%A8%E4%B8%80%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/boltdb/bolt&#34;&gt;boltdb&lt;/a&gt; 是一个使用 Go 编写的键值对数据库，它的目标是 &lt;strong&gt;简单、快速和稳定的轻型数据库&lt;/strong&gt;，适用于那些不需要使用像 MySQL 一样的完整的数据库系统的项目。&lt;/p&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;h3 id=&#34;1-安装&#34;&gt;1. 安装&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go get github.com/boltdb/bolt/...
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-打开open一个数据库文件连接&#34;&gt;2. 打开(Open)一个数据库文件连接&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;dbPath&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;./data.db&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 指定你的数据库文件要存储的地方&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;db&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bolt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Open&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dbPath&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;os&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ModePerm&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		panic(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;bolt&lt;/code&gt; 打开一个文件之后，会一直获得此文件的锁，在这期间，其他的进程无法再次打开此文件，直到最开始的进程释放锁。打开一个已经打开的 bolt文件 会导致当前进程无限制地等待下去，直到另一个已经打开的进程结束这个文件的使&amp;gt; 用。为了避免这种无限制的等待，可以给 &lt;code&gt;Open&lt;/code&gt; 操作添加超时：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang-map详解</title>
      <link>http://localhost:1313/posts/golang-map%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 18 Sep 2020 23:41:39 +0000</pubDate>
      <guid>http://localhost:1313/posts/golang-map%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;一设计原理&#34;&gt;一、设计原理&lt;/h2&gt;
&lt;p&gt;哈希表(也就是我们说的&lt;code&gt;map&lt;/code&gt;)是计算机应用领域非常重要的数据结构之一，读写的时间复杂度均是&lt;code&gt;O(1)&lt;/code&gt;，是典型的 &lt;strong&gt;以空间换时间&lt;/strong&gt; 设计。它的优点除了读写性能优异，还在于它提供了键值之间的映射，为程序设计提供了极大的方便。要想实现一个性能优异的哈希表，需要关注两个关键点：&lt;strong&gt;哈希函数&lt;/strong&gt; 和 &lt;strong&gt;冲突解决方法&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang-GPM调度原理</title>
      <link>http://localhost:1313/posts/golang-gpm%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 18 Sep 2020 01:53:29 +0000</pubDate>
      <guid>http://localhost:1313/posts/golang-gpm%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;一概述&#34;&gt;一、概述&lt;/h2&gt;
&lt;h3 id=&#34;1-为什么在内核的线程调度器之外go-还需要实现一个自己的调度器&#34;&gt;1. 为什么在内核的线程调度器之外，Go 还需要实现一个自己的调度器&lt;/h3&gt;
&lt;p&gt;主要解决&lt;strong&gt;系统线程太重&lt;/strong&gt;的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建与切换线程 太重：都需要在用户态和内核态之间切换，开销较大；&lt;/li&gt;
&lt;li&gt;系统线程内存使用 太重：一方面，创建系统线程时会分配一段大部分情况下都用不完的栈内存，造成浪费；另一方面，栈内存空间创建后其大小不会再变化，有溢出的风险。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;goroutine 是 Go 语言实现的用户态的线程，可以看做是对系统线程进行的一层抽象。有了这层抽象，Golang 程序员不会直接面对系统线程，直接使用 goroutine 就可以了，而操作系统不会 care 什么 goroutine，只是执行设定好的系统线程就好了。这层抽象，就是 Go 的调度器，后面会详细说明。Go 很精巧地解决了上述两个问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang-unsafe包详解</title>
      <link>http://localhost:1313/posts/golang-unsafe%E5%8C%85%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 17 Sep 2020 01:53:29 +0000</pubDate>
      <guid>http://localhost:1313/posts/golang-unsafe%E5%8C%85%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;1-go语言指针的限制&#34;&gt;1. &lt;code&gt;Go&lt;/code&gt;语言指针的限制&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;go&lt;/code&gt;语言中也有指针，但相对&lt;code&gt;C语言&lt;/code&gt;的指针来说，有了很多限制，但这也算是&lt;code&gt;go&lt;/code&gt;的成功之处：既可以享受指针带来的便利，又避免了指针过度使用带来的危险。主要的限制如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang-数组,切片和字符串</title>
      <link>http://localhost:1313/posts/golang-%E6%95%B0%E7%BB%84-%E5%88%87%E7%89%87%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Wed, 16 Sep 2020 02:15:54 +0000</pubDate>
      <guid>http://localhost:1313/posts/golang-%E6%95%B0%E7%BB%84-%E5%88%87%E7%89%87%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>&lt;p&gt;在主流的编程语言中数组及其相关的数据结构是使用得最为频繁的，只有在它(们)不能满足时才会考虑链表、hash 表（hash 表可以看作是数组和链表的混合体）和更复杂的自定义数据结构。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang-关于函数调用</title>
      <link>http://localhost:1313/posts/golang-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</link>
      <pubDate>Tue, 15 Sep 2020 02:05:36 +0000</pubDate>
      <guid>http://localhost:1313/posts/golang-%E5%85%B3%E4%BA%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;一-前言&#34;&gt;一、 前言&lt;/h2&gt;
&lt;p&gt;我们完成程序的编写之后，经过编译，编译器会将我们的程序编译成一行行机器指令，放到一个可执行文件中；程序执行时，可执行文件被加载到内存，机器执行被放置到虚拟内存的“代码段”，并分配以及初始化程序运行过程中需要的堆栈。会形成如下的结构：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
